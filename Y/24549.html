<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>keylen</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/81.html#L622'>keylen</a>            622 ext/dba/dba.c  	int keylen = 0;</span>
<span class='curline'><a href='../S/81.html#L645'>keylen</a>            645 ext/dba/dba.c  		keylen += Z_STRLEN_PP(args[i]);</span>
<span class='curline'><a href='../S/81.html#L652'>keylen</a>            652 ext/dba/dba.c  		key = safe_emalloc(keylen, 1, 1);</span>
<span class='curline'><a href='../S/81.html#L653'>keylen</a>            653 ext/dba/dba.c  		key[keylen] = '\0';</span>
<span class='curline'><a href='../S/81.html#L654'>keylen</a>            654 ext/dba/dba.c  		keylen = 0;</span>
<span class='curline'><a href='../S/81.html#L657'>keylen</a>            657 ext/dba/dba.c  			memcpy(key+keylen, Z_STRVAL_PP(args[i]), Z_STRLEN_PP(args[i]));</span>
<span class='curline'><a href='../S/81.html#L658'>keylen</a>            658 ext/dba/dba.c  			keylen += Z_STRLEN_PP(args[i]);</span>
<span class='curline'><a href='../S/81.html#L662'>keylen</a>            662 ext/dba/dba.c  		if (zend_hash_find(&amp;EG(persistent_list), key, keylen+1, (void **) &amp;le) == SUCCESS) {</span>
<span class='curline'><a href='../S/81.html#L941'>keylen</a>            941 ext/dba/dba.c  		if (zend_hash_update(&amp;EG(persistent_list), key, keylen+1, &amp;new_le, sizeof(zend_rsrc_list_entry), NULL) == FAILURE) {</span>
<span class='curline'><a href='../S/82.html#L159'>keylen</a>            159 ext/dba/dba_cdb.c 	if (php_cdb_find(&amp;cdb-&gt;c, key, keylen) == 1) {</span>
<span class='curline'><a href='../S/82.html#L161'>keylen</a>            161 ext/dba/dba_cdb.c 			if (php_cdb_findnext(&amp;cdb-&gt;c, key, keylen) != 1) {</span>
<span class='curline'><a href='../S/82.html#L189'>keylen</a>            189 ext/dba/dba_cdb.c 	if (cdb_make_add(&amp;cdb-&gt;m, key, keylen, val, vallen TSRMLS_CC) != -1)</span>
<span class='curline'><a href='../S/82.html#L203'>keylen</a>            203 ext/dba/dba_cdb.c 	if (php_cdb_find(&amp;cdb-&gt;c, key, keylen) == 1)</span>
<span class='curline'><a href='../S/83.html#L39'>keylen</a>             39 ext/dba/dba_db1.c #define DB1_GKEY DBT gkey; gkey.data = (char *) key; gkey.size = keylen</span>
<span class='curline'><a href='../S/84.html#L40'>keylen</a>             40 ext/dba/dba_db2.c 	gkey.size = keylen</span>
<span class='curline'><a href='../S/85.html#L49'>keylen</a>             49 ext/dba/dba_db3.c 	gkey.data = (char *) key; gkey.size = keylen</span>
<span class='curline'><a href='../S/86.html#L67'>keylen</a>             67 ext/dba/dba_db4.c 	gkey.data = (char *) key; gkey.size = keylen</span>
<span class='curline'><a href='../S/87.html#L43'>keylen</a>             43 ext/dba/dba_dbm.c #define DBM_GKEY datum gkey; gkey.dptr = (char *) key; gkey.dsize = keylen</span>
<span class='curline'><a href='../S/88.html#L40'>keylen</a>             40 ext/dba/dba_flatfile.c #define FLATFILE_GKEY datum gkey; gkey.dptr = (char *) key; gkey.dsize = keylen</span>
<span class='curline'><a href='../S/89.html#L35'>keylen</a>             35 ext/dba/dba_gdbm.c #define GDBM_GKEY datum gkey; gkey.dptr = (char *) key; gkey.dsize = keylen</span>
<span class='curline'><a href='../S/91.html#L35'>keylen</a>             35 ext/dba/dba_ndbm.c #define NDBM_GKEY datum gkey; gkey.dptr = (char *) key; gkey.dsize = keylen</span>
<span class='curline'><a href='../S/92.html#L86'>keylen</a>             86 ext/dba/dba_qdbm.c 	value = dpget(dba-&gt;dbf, key, keylen, 0, -1, &amp;value_size);</span>
<span class='curline'><a href='../S/92.html#L100'>keylen</a>            100 ext/dba/dba_qdbm.c 	if (dpput(dba-&gt;dbf, key, keylen, val, vallen, mode == 1 ? DP_DKEEP : DP_DOVER)) {</span>
<span class='curline'><a href='../S/92.html#L116'>keylen</a>            116 ext/dba/dba_qdbm.c 	value = dpget(dba-&gt;dbf, key, keylen, 0, -1, NULL);</span>
<span class='curline'><a href='../S/92.html#L129'>keylen</a>            129 ext/dba/dba_qdbm.c 	return dpout(dba-&gt;dbf, key, keylen) ? SUCCESS : FAILURE;</span>
<span class='curline'><a href='../S/93.html#L95'>keylen</a>             95 ext/dba/dba_tcadb.c 	value = tcadbget(dba-&gt;tcadb, key, keylen, &amp;value_size);</span>
<span class='curline'><a href='../S/93.html#L114'>keylen</a>            114 ext/dba/dba_tcadb.c 		if (tcadbvsiz(dba-&gt;tcadb, key, keylen) &gt; -1) {</span>
<span class='curline'><a href='../S/93.html#L119'>keylen</a>            119 ext/dba/dba_tcadb.c 	result = tcadbput(dba-&gt;tcadb, key, keylen, val, vallen);</span>
<span class='curline'><a href='../S/93.html#L135'>keylen</a>            135 ext/dba/dba_tcadb.c 	value = tcadbget(dba-&gt;tcadb, key, keylen, &amp;value_len);</span>
<span class='curline'><a href='../S/93.html#L148'>keylen</a>            148 ext/dba/dba_tcadb.c 	return tcadbout(dba-&gt;tcadb, key, keylen) ? SUCCESS : FAILURE;</span>
<span class='curline'><a href='../S/96.html#L76'>keylen</a>             76 ext/dba/libcdb/cdb_make.c int cdb_make_addend(struct cdb_make *c, unsigned int keylen, unsigned int datalen, uint32 h TSRMLS_DC)</span>
<span class='curline'><a href='../S/96.html#L95'>keylen</a>             95 ext/dba/libcdb/cdb_make.c 	if (cdb_posplus(c, keylen) == -1)</span>
<span class='curline'><a href='../S/96.html#L104'>keylen</a>            104 ext/dba/libcdb/cdb_make.c int cdb_make_addbegin(struct cdb_make *c, unsigned int keylen, unsigned int datalen TSRMLS_DC)</span>
<span class='curline'><a href='../S/96.html#L108'>keylen</a>            108 ext/dba/libcdb/cdb_make.c 	if (keylen &gt; 0xffffffff) {</span>
<span class='curline'><a href='../S/96.html#L117'>keylen</a>            117 ext/dba/libcdb/cdb_make.c 	uint32_pack(buf, keylen);</span>
<span class='curline'><a href='../S/96.html#L125'>keylen</a>            125 ext/dba/libcdb/cdb_make.c int cdb_make_add(struct cdb_make *c,char *key,unsigned int keylen,char *data,unsigned int datalen TSRMLS_DC)</span>
<span class='curline'><a href='../S/96.html#L127'>keylen</a>            127 ext/dba/libcdb/cdb_make.c 	if (cdb_make_addbegin(c, keylen, datalen TSRMLS_CC) == -1)</span>
<span class='curline'><a href='../S/96.html#L129'>keylen</a>            129 ext/dba/libcdb/cdb_make.c 	if (cdb_make_write(c, key, keylen TSRMLS_CC) != 0)</span>
<span class='curline'><a href='../S/96.html#L133'>keylen</a>            133 ext/dba/libcdb/cdb_make.c 	return cdb_make_addend(c, keylen, datalen, cdb_hash(key, keylen) TSRMLS_CC);</span>
<span class='curline'><a href='../S/109.html#L98'>keylen</a>             98 ext/dba/php_dba.h 	char *dba_fetch_##x(dba_info *info, char *key, int keylen, int skip, int *newlen TSRMLS_DC)</span>
<span class='curline'><a href='../S/109.html#L100'>keylen</a>            100 ext/dba/php_dba.h 	int dba_update_##x(dba_info *info, char *key, int keylen, char *val, int vallen, int mode TSRMLS_DC)</span>
<span class='curline'><a href='../S/109.html#L102'>keylen</a>            102 ext/dba/php_dba.h 	int dba_exists_##x(dba_info *info, char *key, int keylen TSRMLS_DC)</span>
<span class='curline'><a href='../S/109.html#L104'>keylen</a>            104 ext/dba/php_dba.h 	int dba_delete_##x(dba_info *info, char *key, int keylen TSRMLS_DC)</span>
<span class='curline'><a href='../S/865.html#L5174'>keylen</a>           5174 ext/openssl/openssl.c 	int i=0, outlen, keylen;</span>
<span class='curline'><a href='../S/865.html#L5187'>keylen</a>           5187 ext/openssl/openssl.c 	keylen = EVP_CIPHER_key_length(cipher_type);</span>
<span class='curline'><a href='../S/865.html#L5188'>keylen</a>           5188 ext/openssl/openssl.c 	if (keylen &gt; password_len) {</span>
<span class='curline'><a href='../S/865.html#L5189'>keylen</a>           5189 ext/openssl/openssl.c 		key = emalloc(keylen);</span>
<span class='curline'><a href='../S/865.html#L5190'>keylen</a>           5190 ext/openssl/openssl.c 		memset(key, 0, keylen);</span>
<span class='curline'><a href='../S/865.html#L5206'>keylen</a>           5206 ext/openssl/openssl.c 	if (password_len &gt; keylen) {</span>
<span class='curline'><a href='../S/865.html#L5253'>keylen</a>           5253 ext/openssl/openssl.c 	int i, outlen, keylen;</span>
<span class='curline'><a href='../S/865.html#L5284'>keylen</a>           5284 ext/openssl/openssl.c 	keylen = EVP_CIPHER_key_length(cipher_type);</span>
<span class='curline'><a href='../S/865.html#L5285'>keylen</a>           5285 ext/openssl/openssl.c 	if (keylen &gt; password_len) {</span>
<span class='curline'><a href='../S/865.html#L5286'>keylen</a>           5286 ext/openssl/openssl.c 		key = emalloc(keylen);</span>
<span class='curline'><a href='../S/865.html#L5287'>keylen</a>           5287 ext/openssl/openssl.c 		memset(key, 0, keylen);</span>
<span class='curline'><a href='../S/865.html#L5299'>keylen</a>           5299 ext/openssl/openssl.c 	if (password_len &gt; keylen) {</span>
<span class='curline'><a href='../S/969.html#L98'>keylen</a>             98 ext/phar/dirstream.c 	uint keylen;</span>
<span class='curline'><a href='../S/969.html#L101'>keylen</a>            101 ext/phar/dirstream.c 	if (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(data, &amp;str_key, &amp;keylen, &amp;unused, 0, NULL)) {</span>
<span class='curline'><a href='../S/969.html#L106'>keylen</a>            106 ext/phar/dirstream.c 	to_read = MIN(keylen, count);</span>
<span class='curline'><a href='../S/969.html#L108'>keylen</a>            108 ext/phar/dirstream.c 	if (to_read == 0 || count &lt; keylen) {</span>
<span class='curline'><a href='../S/969.html#L185'>keylen</a>            185 ext/phar/dirstream.c 	uint keylen;</span>
<span class='curline'><a href='../S/969.html#L201'>keylen</a>            201 ext/phar/dirstream.c 		keylen = 0;</span>
<span class='curline'><a href='../S/969.html#L202'>keylen</a>            202 ext/phar/dirstream.c 		if (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &amp;str_key, &amp;keylen, &amp;unused, 0, NULL)) {</span>
<span class='curline'><a href='../S/969.html#L206'>keylen</a>            206 ext/phar/dirstream.c 		if (keylen &lt;= (uint)dirlen) {</span>
<span class='curline'><a href='../S/969.html#L207'>keylen</a>            207 ext/phar/dirstream.c 			if (keylen == 0 || keylen &lt; (uint)dirlen || !strncmp(str_key, dir, dirlen)) {</span>
<span class='curline'><a href='../S/969.html#L217'>keylen</a>            217 ext/phar/dirstream.c 			if (keylen &gt;= sizeof(".phar")-1 &amp;&amp; !memcmp(str_key, ".phar", sizeof(".phar")-1)) {</span>
<span class='curline'><a href='../S/969.html#L225'>keylen</a>            225 ext/phar/dirstream.c 			if (NULL != (found = (char *) memchr(str_key, '/', keylen))) {</span>
<span class='curline'><a href='../S/969.html#L229'>keylen</a>            229 ext/phar/dirstream.c 				keylen = found - str_key;</span>
<span class='curline'><a href='../S/969.html#L230'>keylen</a>            230 ext/phar/dirstream.c 				entry[keylen] = '\0';</span>
<span class='curline'><a href='../S/969.html#L232'>keylen</a>            232 ext/phar/dirstream.c 				entry = (char *) safe_emalloc(keylen, 1, 1);</span>
<span class='curline'><a href='../S/969.html#L233'>keylen</a>            233 ext/phar/dirstream.c 				memcpy(entry, str_key, keylen);</span>
<span class='curline'><a href='../S/969.html#L234'>keylen</a>            234 ext/phar/dirstream.c 				entry[keylen] = '\0';</span>
<span class='curline'><a href='../S/969.html#L258'>keylen</a>            258 ext/phar/dirstream.c 		if (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {</span>
<span class='curline'><a href='../S/969.html#L263'>keylen</a>            263 ext/phar/dirstream.c 			keylen = found - save - dirlen - 1;</span>
<span class='curline'><a href='../S/969.html#L264'>keylen</a>            264 ext/phar/dirstream.c 			entry[keylen] = '\0';</span>
<span class='curline'><a href='../S/969.html#L268'>keylen</a>            268 ext/phar/dirstream.c 			entry = (char *) safe_emalloc(keylen - dirlen, 1, 1);</span>
<span class='curline'><a href='../S/969.html#L269'>keylen</a>            269 ext/phar/dirstream.c 			memcpy(entry, save + dirlen + 1, keylen - dirlen - 1);</span>
<span class='curline'><a href='../S/969.html#L270'>keylen</a>            270 ext/phar/dirstream.c 			entry[keylen - dirlen - 1] = '\0';</span>
<span class='curline'><a href='../S/969.html#L271'>keylen</a>            271 ext/phar/dirstream.c 			keylen = keylen - dirlen - 1;</span>
<span class='curline'><a href='../S/969.html#L274'>keylen</a>            274 ext/phar/dirstream.c 		if (keylen) {</span>
<span class='curline'><a href='../S/969.html#L275'>keylen</a>            275 ext/phar/dirstream.c 			phar_add_empty(data, entry, keylen);</span>
<span class='curline'><a href='../S/969.html#L307'>keylen</a>            307 ext/phar/dirstream.c 	uint keylen;</span>
<span class='curline'><a href='../S/969.html#L387'>keylen</a>            387 ext/phar/dirstream.c 						&amp;phar-&gt;manifest, &amp;str_key, &amp;keylen, &amp;unused, 0, NULL)) {</span>
<span class='curline'><a href='../S/969.html#L388'>keylen</a>            388 ext/phar/dirstream.c 				if (keylen &gt; (uint)i_len &amp;&amp; 0 == memcmp(str_key, internal_file, i_len)) {</span>
<span class='curline'><a href='../S/973.html#L1959'>keylen</a>           1959 ext/phar/phar.c 			uint keylen;</span>
<span class='curline'><a href='../S/973.html#L1963'>keylen</a>           1963 ext/phar/phar.c 				HASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&amp;(PHAR_GLOBALS-&gt;phar_fname_map), &amp;str_key, &amp;keylen, &amp;unused, 0, NULL);</span>
<span class='curline'><a href='../S/973.html#L1966'>keylen</a>           1966 ext/phar/phar.c 				if (keylen &gt; (uint) filename_len) {</span>
<span class='curline'><a href='../S/973.html#L1970'>keylen</a>           1970 ext/phar/phar.c 				if (!memcmp(filename, str_key, keylen) &amp;&amp; ((uint)filename_len == keylen</span>
<span class='curline'><a href='../S/973.html#L1971'>keylen</a>           1971 ext/phar/phar.c 					|| filename[keylen] == '/' || filename[keylen] == '\0')) {</span>
<span class='curline'><a href='../S/973.html#L1975'>keylen</a>           1975 ext/phar/phar.c 					*ext_str = filename + (keylen - (*pphar)-&gt;ext_len);</span>
<span class='curline'><a href='../S/973.html#L1982'>keylen</a>           1982 ext/phar/phar.c 					HASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&amp;cached_phars, &amp;str_key, &amp;keylen, &amp;unused, 0, NULL);</span>
<span class='curline'><a href='../S/973.html#L1985'>keylen</a>           1985 ext/phar/phar.c 					if (keylen &gt; (uint) filename_len) {</span>
<span class='curline'><a href='../S/973.html#L1989'>keylen</a>           1989 ext/phar/phar.c 					if (!memcmp(filename, str_key, keylen) &amp;&amp; ((uint)filename_len == keylen</span>
<span class='curline'><a href='../S/973.html#L1990'>keylen</a>           1990 ext/phar/phar.c 						|| filename[keylen] == '/' || filename[keylen] == '\0')) {</span>
<span class='curline'><a href='../S/973.html#L1994'>keylen</a>           1994 ext/phar/phar.c 						*ext_str = filename + (keylen - (*pphar)-&gt;ext_len);</span>
<span class='curline'><a href='../S/979.html#L632'>keylen</a>            632 ext/phar/stream.c 		uint keylen;</span>
<span class='curline'><a href='../S/979.html#L636'>keylen</a>            636 ext/phar/stream.c 			HASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&amp;phar-&gt;mounted_dirs, &amp;str_key, &amp;keylen, &amp;unused, 0, &amp;pos);</span>
<span class='curline'><a href='../S/979.html#L639'>keylen</a>            639 ext/phar/stream.c 			if ((int)keylen &gt;= internal_file_len || strncmp(str_key, internal_file, keylen)) {</span>
<span class='curline'><a href='../S/979.html#L646'>keylen</a>            646 ext/phar/stream.c 				if (SUCCESS != zend_hash_find(&amp;phar-&gt;manifest, str_key, keylen, (void **) &amp;entry)) {</span>
<span class='curline'><a href='../S/979.html#L652'>keylen</a>            652 ext/phar/stream.c 				test_len = spprintf(&amp;test, MAXPATHLEN, "%s%s", entry-&gt;tmp, internal_file + keylen);</span>
<span class='curline'><a href='../S/984.html#L1309'>keylen</a>           1309 ext/phar/util.c 		uint keylen;</span>
<span class='curline'><a href='../S/984.html#L1313'>keylen</a>           1313 ext/phar/util.c 			if (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(&amp;phar-&gt;mounted_dirs, &amp;str_key, &amp;keylen, &amp;unused, 0, NULL)) {</span>
<span class='curline'><a href='../S/984.html#L1317'>keylen</a>           1317 ext/phar/util.c 			if ((int)keylen &gt;= path_len || strncmp(str_key, path, keylen)) {</span>
<span class='curline'><a href='../S/984.html#L1324'>keylen</a>           1324 ext/phar/util.c 				if (SUCCESS != zend_hash_find(&amp;phar-&gt;manifest, str_key, keylen, (void **) &amp;entry)) {</span>
<span class='curline'><a href='../S/984.html#L1338'>keylen</a>           1338 ext/phar/util.c 				test_len = spprintf(&amp;test, MAXPATHLEN, "%s%s", entry-&gt;tmp, path + keylen);</span>
<span class='curline'><a href='../S/1000.html#L119'>keylen</a>            119 ext/session/mod_mm.c 	int keylen;</span>
<span class='curline'><a href='../S/1000.html#L121'>keylen</a>            121 ext/session/mod_mm.c 	keylen = strlen(key);</span>
<span class='curline'><a href='../S/1000.html#L123'>keylen</a>            123 ext/session/mod_mm.c 	sd = mm_malloc(data-&gt;mm, sizeof(ps_sd) + keylen);</span>
<span class='curline'><a href='../S/1000.html#L131'>keylen</a>            131 ext/session/mod_mm.c 	hv = ps_sd_hash(key, keylen);</span>
<span class='curline'><a href='../S/1000.html#L139'>keylen</a>            139 ext/session/mod_mm.c 	memcpy(sd-&gt;key, key, keylen + 1);</span>
<span class='curline'><a href='../S/1197.html#L76'>keylen</a>             76 ext/standard/url_scanner_ex.c 			int keylen;</span>
<span class='curline'><a href='../S/1197.html#L81'>keylen</a>             81 ext/standard/url_scanner_ex.c 			keylen = q - key;</span>
<span class='curline'><a href='../S/1197.html#L84'>keylen</a>             84 ext/standard/url_scanner_ex.c 			zend_hash_add(ctx-&gt;tags, key, keylen, val, strlen(val)+1, NULL);</span>
</pre>
</body>
</html>
