<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>za</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.5.4' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1264.html#L49'>za</a>                 49 ext/zip/lib/zip_add.c zip_add(struct zip *za, const char *name, struct zip_source *source)</span>
<span class='curline'><a href='../S/1264.html#L51'>za</a>                 51 ext/zip/lib/zip_add.c     return zip_file_add(za, name, source, 0);</span>
<span class='curline'><a href='../S/1265.html#L44'>za</a>                 44 ext/zip/lib/zip_add_dir.c zip_add_dir(struct zip *za, const char *name)</span>
<span class='curline'><a href='../S/1265.html#L46'>za</a>                 46 ext/zip/lib/zip_add_dir.c     return zip_dir_add(za, name, 0);</span>
<span class='curline'><a href='../S/1266.html#L45'>za</a>                 45 ext/zip/lib/zip_add_entry.c _zip_add_entry(struct zip *za)</span>
<span class='curline'><a href='../S/1266.html#L49'>za</a>                 49 ext/zip/lib/zip_add_entry.c     if (za-&gt;nentry+1 &gt;= za-&gt;nentry_alloc) {</span>
<span class='curline'><a href='../S/1266.html#L51'>za</a>                 51 ext/zip/lib/zip_add_entry.c 	zip_uint64_t nalloc = za-&gt;nentry_alloc + 16;</span>
<span class='curline'><a href='../S/1266.html#L53'>za</a>                 53 ext/zip/lib/zip_add_entry.c 	rentries = (struct zip_entry *)realloc(za-&gt;entry, sizeof(struct zip_entry) * (size_t)nalloc);</span>
<span class='curline'><a href='../S/1266.html#L55'>za</a>                 55 ext/zip/lib/zip_add_entry.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1266.html#L58'>za</a>                 58 ext/zip/lib/zip_add_entry.c 	za-&gt;entry = rentries;</span>
<span class='curline'><a href='../S/1266.html#L59'>za</a>                 59 ext/zip/lib/zip_add_entry.c 	za-&gt;nentry_alloc = nalloc;</span>
<span class='curline'><a href='../S/1266.html#L62'>za</a>                 62 ext/zip/lib/zip_add_entry.c     idx = za-&gt;nentry++;</span>
<span class='curline'><a href='../S/1266.html#L64'>za</a>                 64 ext/zip/lib/zip_add_entry.c     _zip_entry_init(za-&gt;entry+idx);</span>
<span class='curline'><a href='../S/1267.html#L70'>za</a>                 70 ext/zip/lib/zip_close.c zip_close(struct zip *za)</span>
<span class='curline'><a href='../S/1267.html#L86'>za</a>                 86 ext/zip/lib/zip_close.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1267.html#L89'>za</a>                 89 ext/zip/lib/zip_close.c     changed = _zip_changed(za, &amp;survivors);</span>
<span class='curline'><a href='../S/1267.html#L93'>za</a>                 93 ext/zip/lib/zip_close.c 	if (za-&gt;zn &amp;&amp; ((za-&gt;open_flags &amp; ZIP_TRUNCATE) || (changed &amp;&amp; za-&gt;zp))) {</span>
<span class='curline'><a href='../S/1267.html#L94'>za</a>                 94 ext/zip/lib/zip_close.c 	    if (remove(za-&gt;zn) != 0) {</span>
<span class='curline'><a href='../S/1267.html#L95'>za</a>                 95 ext/zip/lib/zip_close.c 		_zip_error_set(&amp;za-&gt;error, ZIP_ER_REMOVE, errno);</span>
<span class='curline'><a href='../S/1267.html#L99'>za</a>                 99 ext/zip/lib/zip_close.c 	zip_discard(za);</span>
<span class='curline'><a href='../S/1267.html#L104'>za</a>                104 ext/zip/lib/zip_close.c 	zip_discard(za);</span>
<span class='curline'><a href='../S/1267.html#L108'>za</a>                108 ext/zip/lib/zip_close.c     if (survivors &gt; za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1267.html#L109'>za</a>                109 ext/zip/lib/zip_close.c         _zip_error_set(&amp;za-&gt;error, ZIP_ER_INTERNAL, 0);</span>
<span class='curline'><a href='../S/1267.html#L117'>za</a>                117 ext/zip/lib/zip_close.c     if (zip_get_archive_flag(za, ZIP_AFL_TORRENT, 0)) {</span>
<span class='curline'><a href='../S/1267.html#L119'>za</a>                119 ext/zip/lib/zip_close.c 	if (zip_set_archive_comment(za, TORRENT_SIG "XXXXXXXX", TORRENT_SIG_LEN + TORRENT_CRC_LEN) &lt; 0) {</span>
<span class='curline'><a href='../S/1267.html#L128'>za</a>                128 ext/zip/lib/zip_close.c     for (i=j=0; i&lt;za-&gt;nentry; i++) {</span>
<span class='curline'><a href='../S/1267.html#L129'>za</a>                129 ext/zip/lib/zip_close.c 	if (za-&gt;entry[i].deleted)</span>
<span class='curline'><a href='../S/1267.html#L134'>za</a>                134 ext/zip/lib/zip_close.c             _zip_error_set(&amp;za-&gt;error, ZIP_ER_INTERNAL, 0);</span>
<span class='curline'><a href='../S/1267.html#L139'>za</a>                139 ext/zip/lib/zip_close.c 	filelist[j].name = zip_get_name(za, i, 0);</span>
<span class='curline'><a href='../S/1267.html#L144'>za</a>                144 ext/zip/lib/zip_close.c         _zip_error_set(&amp;za-&gt;error, ZIP_ER_INTERNAL, 0);</span>
<span class='curline'><a href='../S/1267.html#L149'>za</a>                149 ext/zip/lib/zip_close.c     if ((temp=_zip_create_temp_output(za, &amp;out)) == NULL) {</span>
<span class='curline'><a href='../S/1267.html#L155'>za</a>                155 ext/zip/lib/zip_close.c     if (zip_get_archive_flag(za, ZIP_AFL_TORRENT, 0))</span>
<span class='curline'><a href='../S/1267.html#L159'>za</a>                159 ext/zip/lib/zip_close.c     new_torrentzip = (zip_get_archive_flag(za, ZIP_AFL_TORRENT, 0) == 1</span>
<span class='curline'><a href='../S/1267.html#L160'>za</a>                160 ext/zip/lib/zip_close.c 		      &amp;&amp; zip_get_archive_flag(za, ZIP_AFL_TORRENT,</span>
<span class='curline'><a href='../S/1267.html#L169'>za</a>                169 ext/zip/lib/zip_close.c 	entry = za-&gt;entry+i;</span>
<span class='curline'><a href='../S/1267.html#L176'>za</a>                176 ext/zip/lib/zip_close.c                 _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1267.html#L183'>za</a>                183 ext/zip/lib/zip_close.c 	if (_zip_read_local_ef(za, i) &lt; 0) {</span>
<span class='curline'><a href='../S/1267.html#L188'>za</a>                188 ext/zip/lib/zip_close.c 	if (zip_get_archive_flag(za, ZIP_AFL_TORRENT, 0))</span>
<span class='curline'><a href='../S/1267.html#L199'>za</a>                199 ext/zip/lib/zip_close.c 		if ((zs=_zip_source_zip_new(za, za, i, ZIP_FL_UNCHANGED, 0, 0, NULL)) == NULL) {</span>
<span class='curline'><a href='../S/1267.html#L206'>za</a>                206 ext/zip/lib/zip_close.c 	    if (add_data(za, zs ? zs : entry-&gt;source, de, out) &lt; 0) {</span>
<span class='curline'><a href='../S/1267.html#L220'>za</a>                220 ext/zip/lib/zip_close.c 	    if (_zip_dirent_write(de, out, ZIP_FL_LOCAL, &amp;za-&gt;error) &lt; 0) {</span>
<span class='curline'><a href='../S/1267.html#L224'>za</a>                224 ext/zip/lib/zip_close.c 	    if ((offset=_zip_file_get_offset(za, i, &amp;za-&gt;error)) == 0) {</span>
<span class='curline'><a href='../S/1267.html#L228'>za</a>                228 ext/zip/lib/zip_close.c 	    if ((fseeko(za-&gt;zp, (off_t)offset, SEEK_SET) &lt; 0)) {</span>
<span class='curline'><a href='../S/1267.html#L229'>za</a>                229 ext/zip/lib/zip_close.c 		_zip_error_set(&amp;za-&gt;error, ZIP_ER_SEEK, errno);</span>
<span class='curline'><a href='../S/1267.html#L233'>za</a>                233 ext/zip/lib/zip_close.c 	    if (copy_data(za-&gt;zp, de-&gt;comp_size, out, &amp;za-&gt;error) &lt; 0) {</span>
<span class='curline'><a href='../S/1267.html#L241'>za</a>                241 ext/zip/lib/zip_close.c 	if (write_cdir(za, filelist, survivors, out) &lt; 0)</span>
<span class='curline'><a href='../S/1267.html#L255'>za</a>                255 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_CLOSE, errno);</span>
<span class='curline'><a href='../S/1267.html#L261'>za</a>                261 ext/zip/lib/zip_close.c     if (za-&gt;zp) {</span>
<span class='curline'><a href='../S/1267.html#L262'>za</a>                262 ext/zip/lib/zip_close.c 	fclose(za-&gt;zp);</span>
<span class='curline'><a href='../S/1267.html#L263'>za</a>                263 ext/zip/lib/zip_close.c 	za-&gt;zp = NULL;</span>
<span class='curline'><a href='../S/1267.html#L266'>za</a>                266 ext/zip/lib/zip_close.c     if (_zip_rename(temp, za-&gt;zn) != 0) {</span>
<span class='curline'><a href='../S/1267.html#L267'>za</a>                267 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RENAME, errno);</span>
<span class='curline'><a href='../S/1267.html#L272'>za</a>                272 ext/zip/lib/zip_close.c 	    za-&gt;zp = fopen(za-&gt;zn, "rb");</span>
<span class='curline'><a href='../S/1267.html#L279'>za</a>                279 ext/zip/lib/zip_close.c     chmod(za-&gt;zn, 0666&amp;~mask);</span>
<span class='curline'><a href='../S/1267.html#L282'>za</a>                282 ext/zip/lib/zip_close.c     zip_discard(za);</span>
<span class='curline'><a href='../S/1267.html#L291'>za</a>                291 ext/zip/lib/zip_close.c add_data(struct zip *za, struct zip_source *src, struct zip_dirent *de, FILE *ft)</span>
<span class='curline'><a href='../S/1267.html#L301'>za</a>                301 ext/zip/lib/zip_close.c 	_zip_error_set_from_source(&amp;za-&gt;error, src);</span>
<span class='curline'><a href='../S/1267.html#L343'>za</a>                343 ext/zip/lib/zip_close.c     if ((is_zip64=_zip_dirent_write(de, ft, flags, &amp;za-&gt;error)) &lt; 0)</span>
<span class='curline'><a href='../S/1267.html#L353'>za</a>                353 ext/zip/lib/zip_close.c 		_zip_error_set(&amp;za-&gt;error, ZIP_ER_COMPNOTSUPP, 0);</span>
<span class='curline'><a href='../S/1267.html#L356'>za</a>                356 ext/zip/lib/zip_close.c 	    if ((s_store=comp_impl(za, src, st.comp_method, ZIP_CODEC_DECODE)) == NULL) {</span>
<span class='curline'><a href='../S/1267.html#L364'>za</a>                364 ext/zip/lib/zip_close.c 	if ((s_crc=zip_source_crc(za, s_store, 0)) == NULL) {</span>
<span class='curline'><a href='../S/1267.html#L373'>za</a>                373 ext/zip/lib/zip_close.c 		_zip_error_set(&amp;za-&gt;error, ZIP_ER_COMPNOTSUPP, 0);</span>
<span class='curline'><a href='../S/1267.html#L379'>za</a>                379 ext/zip/lib/zip_close.c 	    if ((s2=comp_impl(za, s_crc, de-&gt;comp_method, ZIP_CODEC_ENCODE)) == NULL) {</span>
<span class='curline'><a href='../S/1267.html#L394'>za</a>                394 ext/zip/lib/zip_close.c     ret = copy_source(za, s2, ft);</span>
<span class='curline'><a href='../S/1267.html#L413'>za</a>                413 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_SEEK, errno);</span>
<span class='curline'><a href='../S/1267.html#L418'>za</a>                418 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INTERNAL, 0);</span>
<span class='curline'><a href='../S/1267.html#L431'>za</a>                431 ext/zip/lib/zip_close.c     if (zip_get_archive_flag(za, ZIP_AFL_TORRENT, 0))</span>
<span class='curline'><a href='../S/1267.html#L434'>za</a>                434 ext/zip/lib/zip_close.c     if ((ret=_zip_dirent_write(de, ft, flags, &amp;za-&gt;error)) &lt; 0)</span>
<span class='curline'><a href='../S/1267.html#L439'>za</a>                439 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INTERNAL, 0);</span>
<span class='curline'><a href='../S/1267.html#L445'>za</a>                445 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_SEEK, errno);</span>
<span class='curline'><a href='../S/1267.html#L490'>za</a>                490 ext/zip/lib/zip_close.c copy_source(struct zip *za, struct zip_source *src, FILE *ft)</span>
<span class='curline'><a href='../S/1267.html#L497'>za</a>                497 ext/zip/lib/zip_close.c 	_zip_error_set_from_source(&amp;za-&gt;error, src);</span>
<span class='curline'><a href='../S/1267.html#L504'>za</a>                504 ext/zip/lib/zip_close.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_WRITE, errno);</span>
<span class='curline'><a href='../S/1267.html#L512'>za</a>                512 ext/zip/lib/zip_close.c 	    _zip_error_set_from_source(&amp;za-&gt;error, src);</span>
<span class='curline'><a href='../S/1267.html#L524'>za</a>                524 ext/zip/lib/zip_close.c write_cdir(struct zip *za, const struct zip_filelist *filelist, zip_uint64_t survivors, FILE *out)</span>
<span class='curline'><a href='../S/1267.html#L533'>za</a>                533 ext/zip/lib/zip_close.c     if ((size=_zip_cdir_write(za, filelist, survivors, out)) &lt; 0)</span>
<span class='curline'><a href='../S/1267.html#L538'>za</a>                538 ext/zip/lib/zip_close.c     if (zip_get_archive_flag(za, ZIP_AFL_TORRENT, 0) == 0)</span>
<span class='curline'><a href='../S/1267.html#L544'>za</a>                544 ext/zip/lib/zip_close.c     if (_zip_filerange_crc(out, cd_start, size, &amp;crc, &amp;za-&gt;error) &lt; 0)</span>
<span class='curline'><a href='../S/1267.html#L550'>za</a>                550 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_SEEK, errno);</span>
<span class='curline'><a href='../S/1267.html#L555'>za</a>                555 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_WRITE, errno);</span>
<span class='curline'><a href='../S/1267.html#L565'>za</a>                565 ext/zip/lib/zip_close.c _zip_changed(const struct zip *za, zip_uint64_t *survivorsp)</span>
<span class='curline'><a href='../S/1267.html#L573'>za</a>                573 ext/zip/lib/zip_close.c     if (za-&gt;comment_changed || za-&gt;ch_flags != za-&gt;flags)</span>
<span class='curline'><a href='../S/1267.html#L576'>za</a>                576 ext/zip/lib/zip_close.c     for (i=0; i&lt;za-&gt;nentry; i++) {</span>
<span class='curline'><a href='../S/1267.html#L577'>za</a>                577 ext/zip/lib/zip_close.c 	if (za-&gt;entry[i].deleted || za-&gt;entry[i].source || (za-&gt;entry[i].changes &amp;&amp; za-&gt;entry[i].changes-&gt;changed != 0))</span>
<span class='curline'><a href='../S/1267.html#L579'>za</a>                579 ext/zip/lib/zip_close.c 	if (!za-&gt;entry[i].deleted)</span>
<span class='curline'><a href='../S/1267.html#L592'>za</a>                592 ext/zip/lib/zip_close.c _zip_create_temp_output(struct zip *za, FILE **outp)</span>
<span class='curline'><a href='../S/1267.html#L598'>za</a>                598 ext/zip/lib/zip_close.c     if (za-&gt;tempdir) {</span>
<span class='curline'><a href='../S/1267.html#L599'>za</a>                599 ext/zip/lib/zip_close.c         if ((temp=(char *)malloc(strlen(za-&gt;tempdir)+13)) == NULL) {</span>
<span class='curline'><a href='../S/1267.html#L600'>za</a>                600 ext/zip/lib/zip_close.c             _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1267.html#L603'>za</a>                603 ext/zip/lib/zip_close.c         sprintf(temp, "%s/.zip.XXXXXX", za-&gt;tempdir);</span>
<span class='curline'><a href='../S/1267.html#L606'>za</a>                606 ext/zip/lib/zip_close.c         if ((temp=(char *)malloc(strlen(za-&gt;zn)+8)) == NULL) {</span>
<span class='curline'><a href='../S/1267.html#L607'>za</a>                607 ext/zip/lib/zip_close.c             _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1267.html#L610'>za</a>                610 ext/zip/lib/zip_close.c         sprintf(temp, "%s.XXXXXX", za-&gt;zn);</span>
<span class='curline'><a href='../S/1267.html#L614'>za</a>                614 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_TMPOPEN, errno);</span>
<span class='curline'><a href='../S/1267.html#L620'>za</a>                620 ext/zip/lib/zip_close.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_TMPOPEN, errno);</span>
<span class='curline'><a href='../S/1268.html#L41'>za</a>                 41 ext/zip/lib/zip_delete.c zip_delete(struct zip *za, zip_uint64_t idx)</span>
<span class='curline'><a href='../S/1268.html#L43'>za</a>                 43 ext/zip/lib/zip_delete.c     if (idx &gt;= za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1268.html#L44'>za</a>                 44 ext/zip/lib/zip_delete.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1268.html#L48'>za</a>                 48 ext/zip/lib/zip_delete.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1268.html#L49'>za</a>                 49 ext/zip/lib/zip_delete.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1268.html#L55'>za</a>                 55 ext/zip/lib/zip_delete.c     if (_zip_unchange(za, idx, 1) != 0)</span>
<span class='curline'><a href='../S/1268.html#L58'>za</a>                 58 ext/zip/lib/zip_delete.c     za-&gt;entry[idx].deleted = 1;</span>
<span class='curline'><a href='../S/1269.html#L46'>za</a>                 46 ext/zip/lib/zip_dir_add.c zip_dir_add(struct zip *za, const char *name, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1269.html#L53'>za</a>                 53 ext/zip/lib/zip_dir_add.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1269.html#L54'>za</a>                 54 ext/zip/lib/zip_dir_add.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1269.html#L59'>za</a>                 59 ext/zip/lib/zip_dir_add.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1269.html#L68'>za</a>                 68 ext/zip/lib/zip_dir_add.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1269.html#L76'>za</a>                 76 ext/zip/lib/zip_dir_add.c     if ((source=zip_source_buffer(za, NULL, 0, 0)) == NULL) {</span>
<span class='curline'><a href='../S/1269.html#L81'>za</a>                 81 ext/zip/lib/zip_dir_add.c     idx = _zip_file_replace(za, ZIP_UINT64_MAX, s ? s : name, source, flags);</span>
<span class='curline'><a href='../S/1269.html#L88'>za</a>                 88 ext/zip/lib/zip_dir_add.c 	if (zip_file_set_external_attributes(za, (zip_uint64_t)idx, 0, ZIP_OPSYS_DEFAULT, ZIP_EXT_ATTRIB_DEFAULT_DIR) &lt; 0) {</span>
<span class='curline'><a href='../S/1269.html#L89'>za</a>                 89 ext/zip/lib/zip_dir_add.c 	    zip_delete(za, (zip_uint64_t)idx);</span>
<span class='curline'><a href='../S/1270.html#L132'>za</a>                132 ext/zip/lib/zip_dirent.c _zip_cdir_write(struct zip *za, const struct zip_filelist *filelist, zip_uint64_t survivors, FILE *fp)</span>
<span class='curline'><a href='../S/1270.html#L142'>za</a>                142 ext/zip/lib/zip_dirent.c         _zip_error_set(&amp;za-&gt;error, ZIP_ER_READ, errno);</span>
<span class='curline'><a href='../S/1270.html#L150'>za</a>                150 ext/zip/lib/zip_dirent.c 	struct zip_entry *entry = za-&gt;entry+filelist[i].idx;</span>
<span class='curline'><a href='../S/1270.html#L152'>za</a>                152 ext/zip/lib/zip_dirent.c 	if ((ret=_zip_dirent_write(entry-&gt;changes ? entry-&gt;changes : entry-&gt;orig, fp, ZIP_FL_CENTRAL, &amp;za-&gt;error)) &lt; 0)</span>
<span class='curline'><a href='../S/1270.html#L159'>za</a>                159 ext/zip/lib/zip_dirent.c         _zip_error_set(&amp;za-&gt;error, ZIP_ER_READ, errno);</span>
<span class='curline'><a href='../S/1270.html#L194'>za</a>                194 ext/zip/lib/zip_dirent.c     comment = za-&gt;comment_changed ? za-&gt;comment_changes : za-&gt;comment_orig;</span>
<span class='curline'><a href='../S/1270.html#L201'>za</a>                201 ext/zip/lib/zip_dirent.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_WRITE, errno);</span>
<span class='curline'><a href='../S/1270.html#L821'>za</a>                821 ext/zip/lib/zip_dirent.c _zip_get_dirent(struct zip *za, zip_uint64_t idx, zip_flags_t flags, struct zip_error *error)</span>
<span class='curline'><a href='../S/1270.html#L824'>za</a>                824 ext/zip/lib/zip_dirent.c 	error = &amp;za-&gt;error;</span>
<span class='curline'><a href='../S/1270.html#L826'>za</a>                826 ext/zip/lib/zip_dirent.c     if (idx &gt;= za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1270.html#L831'>za</a>                831 ext/zip/lib/zip_dirent.c     if ((flags &amp; ZIP_FL_UNCHANGED) || za-&gt;entry[idx].changes == NULL) {</span>
<span class='curline'><a href='../S/1270.html#L832'>za</a>                832 ext/zip/lib/zip_dirent.c 	if (za-&gt;entry[idx].orig == NULL) {</span>
<span class='curline'><a href='../S/1270.html#L836'>za</a>                836 ext/zip/lib/zip_dirent.c 	if (za-&gt;entry[idx].deleted &amp;&amp; (flags &amp; ZIP_FL_UNCHANGED) == 0) {</span>
<span class='curline'><a href='../S/1270.html#L840'>za</a>                840 ext/zip/lib/zip_dirent.c 	return za-&gt;entry[idx].orig;</span>
<span class='curline'><a href='../S/1270.html#L843'>za</a>                843 ext/zip/lib/zip_dirent.c 	return za-&gt;entry[idx].changes;</span>
<span class='curline'><a href='../S/1271.html#L47'>za</a>                 47 ext/zip/lib/zip_discard.c zip_discard(struct zip *za)</span>
<span class='curline'><a href='../S/1271.html#L51'>za</a>                 51 ext/zip/lib/zip_discard.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1271.html#L54'>za</a>                 54 ext/zip/lib/zip_discard.c     if (za-&gt;zn)</span>
<span class='curline'><a href='../S/1271.html#L55'>za</a>                 55 ext/zip/lib/zip_discard.c 	free(za-&gt;zn);</span>
<span class='curline'><a href='../S/1271.html#L57'>za</a>                 57 ext/zip/lib/zip_discard.c     if (za-&gt;zp)</span>
<span class='curline'><a href='../S/1271.html#L58'>za</a>                 58 ext/zip/lib/zip_discard.c 	fclose(za-&gt;zp);</span>
<span class='curline'><a href='../S/1271.html#L60'>za</a>                 60 ext/zip/lib/zip_discard.c     free(za-&gt;default_password);</span>
<span class='curline'><a href='../S/1271.html#L61'>za</a>                 61 ext/zip/lib/zip_discard.c     _zip_string_free(za-&gt;comment_orig);</span>
<span class='curline'><a href='../S/1271.html#L62'>za</a>                 62 ext/zip/lib/zip_discard.c     _zip_string_free(za-&gt;comment_changes);</span>
<span class='curline'><a href='../S/1271.html#L64'>za</a>                 64 ext/zip/lib/zip_discard.c     if (za-&gt;entry) {</span>
<span class='curline'><a href='../S/1271.html#L65'>za</a>                 65 ext/zip/lib/zip_discard.c 	for (i=0; i&lt;za-&gt;nentry; i++)</span>
<span class='curline'><a href='../S/1271.html#L66'>za</a>                 66 ext/zip/lib/zip_discard.c 	    _zip_entry_finalize(za-&gt;entry+i);</span>
<span class='curline'><a href='../S/1271.html#L67'>za</a>                 67 ext/zip/lib/zip_discard.c 	free(za-&gt;entry);</span>
<span class='curline'><a href='../S/1271.html#L70'>za</a>                 70 ext/zip/lib/zip_discard.c     for (i=0; i&lt;za-&gt;nfile; i++) {</span>
<span class='curline'><a href='../S/1271.html#L71'>za</a>                 71 ext/zip/lib/zip_discard.c 	if (za-&gt;file[i]-&gt;error.zip_err == ZIP_ER_OK) {</span>
<span class='curline'><a href='../S/1271.html#L72'>za</a>                 72 ext/zip/lib/zip_discard.c 	    _zip_error_set(&amp;za-&gt;file[i]-&gt;error, ZIP_ER_ZIPCLOSED, 0);</span>
<span class='curline'><a href='../S/1271.html#L73'>za</a>                 73 ext/zip/lib/zip_discard.c 	    za-&gt;file[i]-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1271.html#L77'>za</a>                 77 ext/zip/lib/zip_discard.c     _zip_error_fini(&amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1271.html#L78'>za</a>                 78 ext/zip/lib/zip_discard.c     free(za-&gt;file);</span>
<span class='curline'><a href='../S/1271.html#L80'>za</a>                 80 ext/zip/lib/zip_discard.c     free(za);</span>
<span class='curline'><a href='../S/1275.html#L41'>za</a>                 41 ext/zip/lib/zip_error_clear.c zip_error_clear(struct zip *za)</span>
<span class='curline'><a href='../S/1275.html#L43'>za</a>                 43 ext/zip/lib/zip_error_clear.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1275.html#L46'>za</a>                 46 ext/zip/lib/zip_error_clear.c     _zip_error_clear(&amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1276.html#L41'>za</a>                 41 ext/zip/lib/zip_error_get.c zip_error_get(struct zip *za, int *zep, int *sep)</span>
<span class='curline'><a href='../S/1276.html#L43'>za</a>                 43 ext/zip/lib/zip_error_get.c     _zip_error_get(&amp;za-&gt;error, zep, sep);</span>
<span class='curline'><a href='../S/1280.html#L322'>za</a>                322 ext/zip/lib/zip_extra_field.c _zip_read_local_ef(struct zip *za, zip_uint64_t idx)</span>
<span class='curline'><a href='../S/1280.html#L329'>za</a>                329 ext/zip/lib/zip_extra_field.c     if (idx &gt;= za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1280.html#L330'>za</a>                330 ext/zip/lib/zip_extra_field.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1280.html#L334'>za</a>                334 ext/zip/lib/zip_extra_field.c     e = za-&gt;entry+idx;</span>
<span class='curline'><a href='../S/1280.html#L340'>za</a>                340 ext/zip/lib/zip_extra_field.c     if (fseeko(za-&gt;zp, (off_t)(e-&gt;orig-&gt;offset + 26), SEEK_SET) &lt; 0) {</span>
<span class='curline'><a href='../S/1280.html#L341'>za</a>                341 ext/zip/lib/zip_extra_field.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_SEEK, errno);</span>
<span class='curline'><a href='../S/1280.html#L345'>za</a>                345 ext/zip/lib/zip_extra_field.c     if (fread(b, sizeof(b), 1, za-&gt;zp) != 1) {</span>
<span class='curline'><a href='../S/1280.html#L346'>za</a>                346 ext/zip/lib/zip_extra_field.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_READ, errno);</span>
<span class='curline'><a href='../S/1280.html#L358'>za</a>                358 ext/zip/lib/zip_extra_field.c 	if (fseek(za-&gt;zp, fname_len, SEEK_CUR) &lt; 0) {</span>
<span class='curline'><a href='../S/1280.html#L359'>za</a>                359 ext/zip/lib/zip_extra_field.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_SEEK, errno);</span>
<span class='curline'><a href='../S/1280.html#L363'>za</a>                363 ext/zip/lib/zip_extra_field.c 	ef_raw = _zip_read_data(NULL, za-&gt;zp, ef_len, 0, &amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1280.html#L368'>za</a>                368 ext/zip/lib/zip_extra_field.c 	if ((ef=_zip_ef_parse(ef_raw, ef_len, ZIP_EF_LOCAL, &amp;za-&gt;error)) == NULL) {</span>
<span class='curline'><a href='../S/1281.html#L41'>za</a>                 41 ext/zip/lib/zip_extra_field_api.c zip_file_extra_field_delete(struct zip *za, zip_uint64_t idx, zip_uint16_t ef_idx, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1281.html#L46'>za</a>                 46 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L51'>za</a>                 51 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L55'>za</a>                 55 ext/zip/lib/zip_extra_field_api.c     if (_zip_get_dirent(za, idx, 0, NULL) == NULL)</span>
<span class='curline'><a href='../S/1281.html#L58'>za</a>                 58 ext/zip/lib/zip_extra_field_api.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1281.html#L59'>za</a>                 59 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1281.html#L63'>za</a>                 63 ext/zip/lib/zip_extra_field_api.c     if (_zip_file_extra_field_prepare_for_change(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L66'>za</a>                 66 ext/zip/lib/zip_extra_field_api.c     de = za-&gt;entry[idx].changes;</span>
<span class='curline'><a href='../S/1281.html#L75'>za</a>                 75 ext/zip/lib/zip_extra_field_api.c zip_file_extra_field_delete_by_id(struct zip *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_uint16_t ef_idx, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1281.html#L80'>za</a>                 80 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L85'>za</a>                 85 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L89'>za</a>                 89 ext/zip/lib/zip_extra_field_api.c     if (_zip_get_dirent(za, idx, 0, NULL) == NULL)</span>
<span class='curline'><a href='../S/1281.html#L92'>za</a>                 92 ext/zip/lib/zip_extra_field_api.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1281.html#L93'>za</a>                 93 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1281.html#L97'>za</a>                 97 ext/zip/lib/zip_extra_field_api.c     if (_zip_file_extra_field_prepare_for_change(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L100'>za</a>                100 ext/zip/lib/zip_extra_field_api.c     de = za-&gt;entry[idx].changes;</span>
<span class='curline'><a href='../S/1281.html#L109'>za</a>                109 ext/zip/lib/zip_extra_field_api.c zip_file_extra_field_get(struct zip *za, zip_uint64_t idx, zip_uint16_t ef_idx, zip_uint16_t *idp, zip_uint16_t *lenp, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1281.html#L118'>za</a>                118 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L122'>za</a>                122 ext/zip/lib/zip_extra_field_api.c     if ((de=_zip_get_dirent(za, idx, flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1281.html#L126'>za</a>                126 ext/zip/lib/zip_extra_field_api.c 	if (_zip_read_local_ef(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L148'>za</a>                148 ext/zip/lib/zip_extra_field_api.c     _zip_error_set(&amp;za-&gt;error, ZIP_ER_NOENT, 0);</span>
<span class='curline'><a href='../S/1281.html#L156'>za</a>                156 ext/zip/lib/zip_extra_field_api.c zip_file_extra_field_get_by_id(struct zip *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_uint16_t ef_idx, zip_uint16_t *lenp, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1281.html#L161'>za</a>                161 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L165'>za</a>                165 ext/zip/lib/zip_extra_field_api.c     if ((de=_zip_get_dirent(za, idx, flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1281.html#L169'>za</a>                169 ext/zip/lib/zip_extra_field_api.c 	if (_zip_read_local_ef(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L172'>za</a>                172 ext/zip/lib/zip_extra_field_api.c     return _zip_ef_get_by_id(de-&gt;extra_fields, lenp, ef_id, ef_idx, flags, &amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1281.html#L178'>za</a>                178 ext/zip/lib/zip_extra_field_api.c zip_file_extra_fields_count(struct zip *za, zip_uint64_t idx, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1281.html#L185'>za</a>                185 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L189'>za</a>                189 ext/zip/lib/zip_extra_field_api.c     if ((de=_zip_get_dirent(za, idx, flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1281.html#L193'>za</a>                193 ext/zip/lib/zip_extra_field_api.c 	if (_zip_read_local_ef(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L207'>za</a>                207 ext/zip/lib/zip_extra_field_api.c zip_file_extra_fields_count_by_id(struct zip *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1281.html#L214'>za</a>                214 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L218'>za</a>                218 ext/zip/lib/zip_extra_field_api.c     if ((de=_zip_get_dirent(za, idx, flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1281.html#L222'>za</a>                222 ext/zip/lib/zip_extra_field_api.c 	if (_zip_read_local_ef(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L236'>za</a>                236 ext/zip/lib/zip_extra_field_api.c zip_file_extra_field_set(struct zip *za, zip_uint64_t idx, zip_uint16_t ef_id, zip_uint16_t ef_idx, const zip_uint8_t *data, zip_uint16_t len, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1281.html#L244'>za</a>                244 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L248'>za</a>                248 ext/zip/lib/zip_extra_field_api.c     if (_zip_get_dirent(za, idx, 0, NULL) == NULL)</span>
<span class='curline'><a href='../S/1281.html#L251'>za</a>                251 ext/zip/lib/zip_extra_field_api.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1281.html#L252'>za</a>                252 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1281.html#L257'>za</a>                257 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L261'>za</a>                261 ext/zip/lib/zip_extra_field_api.c     if (_zip_file_extra_field_prepare_for_change(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L264'>za</a>                264 ext/zip/lib/zip_extra_field_api.c     de = za-&gt;entry[idx].changes;</span>
<span class='curline'><a href='../S/1281.html#L283'>za</a>                283 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L302'>za</a>                302 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L307'>za</a>                307 ext/zip/lib/zip_extra_field_api.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1281.html#L340'>za</a>                340 ext/zip/lib/zip_extra_field_api.c _zip_file_extra_field_prepare_for_change(struct zip *za, zip_uint64_t idx)</span>
<span class='curline'><a href='../S/1281.html#L344'>za</a>                344 ext/zip/lib/zip_extra_field_api.c     if (idx &gt;= za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1281.html#L345'>za</a>                345 ext/zip/lib/zip_extra_field_api.c         _zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1281.html#L349'>za</a>                349 ext/zip/lib/zip_extra_field_api.c     e = za-&gt;entry+idx;</span>
<span class='curline'><a href='../S/1281.html#L355'>za</a>                355 ext/zip/lib/zip_extra_field_api.c 	if (_zip_read_local_ef(za, idx) &lt; 0)</span>
<span class='curline'><a href='../S/1281.html#L361'>za</a>                361 ext/zip/lib/zip_extra_field_api.c             _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1281.html#L367'>za</a>                367 ext/zip/lib/zip_extra_field_api.c 	if ((e-&gt;changes-&gt;extra_fields=_zip_ef_clone(e-&gt;orig-&gt;extra_fields, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1282.html#L51'>za</a>                 51 ext/zip/lib/zip_fclose.c     if (zf-&gt;za) {</span>
<span class='curline'><a href='../S/1282.html#L52'>za</a>                 52 ext/zip/lib/zip_fclose.c         for (i=0; i&lt;zf-&gt;za-&gt;nfile; i++) {</span>
<span class='curline'><a href='../S/1282.html#L53'>za</a>                 53 ext/zip/lib/zip_fclose.c             if (zf-&gt;za-&gt;file[i] == zf) {</span>
<span class='curline'><a href='../S/1282.html#L54'>za</a>                 54 ext/zip/lib/zip_fclose.c                 zf-&gt;za-&gt;file[i] = zf-&gt;za-&gt;file[zf-&gt;za-&gt;nfile-1];</span>
<span class='curline'><a href='../S/1282.html#L55'>za</a>                 55 ext/zip/lib/zip_fclose.c                 zf-&gt;za-&gt;nfile--;</span>
<span class='curline'><a href='../S/1284.html#L47'>za</a>                 47 ext/zip/lib/zip_file_add.c zip_file_add(struct zip *za, const char *name, struct zip_source *source, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1284.html#L50'>za</a>                 50 ext/zip/lib/zip_file_add.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1284.html#L54'>za</a>                 54 ext/zip/lib/zip_file_add.c     return _zip_file_replace(za, ZIP_UINT64_MAX, name, source, flags);</span>
<span class='curline'><a href='../S/1287.html#L42'>za</a>                 42 ext/zip/lib/zip_file_get_comment.c zip_file_get_comment(struct zip *za, zip_uint64_t idx, zip_uint32_t *lenp, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1287.html#L48'>za</a>                 48 ext/zip/lib/zip_file_get_comment.c     if ((de=_zip_get_dirent(za, idx, flags, NULL)) == NULL)</span>
<span class='curline'><a href='../S/1287.html#L51'>za</a>                 51 ext/zip/lib/zip_file_get_comment.c     if ((str=_zip_string_get(de-&gt;comment, &amp;len, flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1288.html#L37'>za</a>                 37 ext/zip/lib/zip_file_get_external_attributes.c zip_file_get_external_attributes(struct zip *za, zip_uint64_t idx, zip_flags_t flags, zip_uint8_t *opsys, zip_uint32_t *attributes)</span>
<span class='curline'><a href='../S/1288.html#L43'>za</a>                 43 ext/zip/lib/zip_file_get_external_attributes.c     if ((de=_zip_get_dirent(za, idx, flags, NULL)) == NULL)</span>
<span class='curline'><a href='../S/1289.html#L54'>za</a>                 54 ext/zip/lib/zip_file_get_offset.c _zip_file_get_offset(const struct zip *za, zip_uint64_t idx, struct zip_error *error)</span>
<span class='curline'><a href='../S/1289.html#L59'>za</a>                 59 ext/zip/lib/zip_file_get_offset.c     offset = za-&gt;entry[idx].orig-&gt;offset;</span>
<span class='curline'><a href='../S/1289.html#L61'>za</a>                 61 ext/zip/lib/zip_file_get_offset.c     if (fseeko(za-&gt;zp, (off_t)offset, SEEK_SET) != 0) {</span>
<span class='curline'><a href='../S/1289.html#L67'>za</a>                 67 ext/zip/lib/zip_file_get_offset.c     if ((size=_zip_dirent_size(za-&gt;zp, ZIP_EF_LOCAL, error)) &lt; 0)</span>
<span class='curline'><a href='../S/1290.html#L43'>za</a>                 43 ext/zip/lib/zip_file_rename.c zip_file_rename(struct zip *za, zip_uint64_t idx, const char *name, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1290.html#L48'>za</a>                 48 ext/zip/lib/zip_file_rename.c     if (idx &gt;= za-&gt;nentry || (name != NULL &amp;&amp; strlen(name) &gt; ZIP_UINT16_MAX)) {</span>
<span class='curline'><a href='../S/1290.html#L49'>za</a>                 49 ext/zip/lib/zip_file_rename.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1290.html#L53'>za</a>                 53 ext/zip/lib/zip_file_rename.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1290.html#L54'>za</a>                 54 ext/zip/lib/zip_file_rename.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1290.html#L58'>za</a>                 58 ext/zip/lib/zip_file_rename.c     if ((old_name=zip_get_name(za, idx, 0)) == NULL)</span>
<span class='curline'><a href='../S/1290.html#L65'>za</a>                 65 ext/zip/lib/zip_file_rename.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1290.html#L69'>za</a>                 69 ext/zip/lib/zip_file_rename.c     return _zip_set_name(za, idx, name, flags);</span>
<span class='curline'><a href='../S/1291.html#L41'>za</a>                 41 ext/zip/lib/zip_file_replace.c zip_file_replace(struct zip *za, zip_uint64_t idx, struct zip_source *source, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1291.html#L43'>za</a>                 43 ext/zip/lib/zip_file_replace.c     if (idx &gt;= za-&gt;nentry || source == NULL) {</span>
<span class='curline'><a href='../S/1291.html#L44'>za</a>                 44 ext/zip/lib/zip_file_replace.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1291.html#L48'>za</a>                 48 ext/zip/lib/zip_file_replace.c     if (_zip_file_replace(za, idx, NULL, source, flags) == -1)</span>
<span class='curline'><a href='../S/1291.html#L60'>za</a>                 60 ext/zip/lib/zip_file_replace.c _zip_file_replace(struct zip *za, zip_uint64_t idx, const char *name, struct zip_source *source, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1291.html#L64'>za</a>                 64 ext/zip/lib/zip_file_replace.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1291.html#L65'>za</a>                 65 ext/zip/lib/zip_file_replace.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1291.html#L69'>za</a>                 69 ext/zip/lib/zip_file_replace.c     za_nentry_prev = za-&gt;nentry;</span>
<span class='curline'><a href='../S/1291.html#L74'>za</a>                 74 ext/zip/lib/zip_file_replace.c 	    i = _zip_name_locate(za, name, flags, NULL);</span>
<span class='curline'><a href='../S/1291.html#L78'>za</a>                 78 ext/zip/lib/zip_file_replace.c 	    if ((i=_zip_add_entry(za)) &lt; 0)</span>
<span class='curline'><a href='../S/1291.html#L84'>za</a>                 84 ext/zip/lib/zip_file_replace.c     if (name &amp;&amp; _zip_set_name(za, idx, name, flags) != 0) {</span>
<span class='curline'><a href='../S/1291.html#L85'>za</a>                 85 ext/zip/lib/zip_file_replace.c 	if (za-&gt;nentry != za_nentry_prev) {</span>
<span class='curline'><a href='../S/1291.html#L86'>za</a>                 86 ext/zip/lib/zip_file_replace.c 	    _zip_entry_finalize(za-&gt;entry+idx);</span>
<span class='curline'><a href='../S/1291.html#L87'>za</a>                 87 ext/zip/lib/zip_file_replace.c 	    za-&gt;nentry = za_nentry_prev;</span>
<span class='curline'><a href='../S/1291.html#L94'>za</a>                 94 ext/zip/lib/zip_file_replace.c     _zip_unchange_data(za-&gt;entry+idx);</span>
<span class='curline'><a href='../S/1291.html#L96'>za</a>                 96 ext/zip/lib/zip_file_replace.c     if (za-&gt;entry[idx].orig != NULL &amp;&amp; (za-&gt;entry[idx].changes == NULL || (za-&gt;entry[idx].changes-&gt;changed &amp; ZIP_DIRENT_COMP_METHOD) == 0)) {</span>
<span class='curline'><a href='../S/1291.html#L97'>za</a>                 97 ext/zip/lib/zip_file_replace.c         if (za-&gt;entry[idx].changes == NULL) {</span>
<span class='curline'><a href='../S/1291.html#L98'>za</a>                 98 ext/zip/lib/zip_file_replace.c             if ((za-&gt;entry[idx].changes=_zip_dirent_clone(za-&gt;entry[idx].orig)) == NULL) {</span>
<span class='curline'><a href='../S/1291.html#L99'>za</a>                 99 ext/zip/lib/zip_file_replace.c                 _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1291.html#L104'>za</a>                104 ext/zip/lib/zip_file_replace.c         za-&gt;entry[idx].changes-&gt;comp_method = ZIP_CM_REPLACED_DEFAULT;</span>
<span class='curline'><a href='../S/1291.html#L105'>za</a>                105 ext/zip/lib/zip_file_replace.c         za-&gt;entry[idx].changes-&gt;changed |= ZIP_DIRENT_COMP_METHOD;</span>
<span class='curline'><a href='../S/1291.html#L108'>za</a>                108 ext/zip/lib/zip_file_replace.c     za-&gt;entry[idx].source = source;</span>
<span class='curline'><a href='../S/1292.html#L43'>za</a>                 43 ext/zip/lib/zip_file_set_comment.c zip_file_set_comment(struct zip *za, zip_uint64_t idx,</span>
<span class='curline'><a href='../S/1292.html#L50'>za</a>                 50 ext/zip/lib/zip_file_set_comment.c     if (_zip_get_dirent(za, idx, 0, NULL) == NULL)</span>
<span class='curline'><a href='../S/1292.html#L53'>za</a>                 53 ext/zip/lib/zip_file_set_comment.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1292.html#L54'>za</a>                 54 ext/zip/lib/zip_file_set_comment.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1292.html#L59'>za</a>                 59 ext/zip/lib/zip_file_set_comment.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1292.html#L64'>za</a>                 64 ext/zip/lib/zip_file_set_comment.c 	if ((cstr=_zip_string_new((const zip_uint8_t *)comment, len, flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1292.html#L72'>za</a>                 72 ext/zip/lib/zip_file_set_comment.c     e = za-&gt;entry+idx;</span>
<span class='curline'><a href='../S/1292.html#L88'>za</a>                 88 ext/zip/lib/zip_file_set_comment.c                 _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1293.html#L37'>za</a>                 37 ext/zip/lib/zip_file_set_external_attributes.c zip_file_set_external_attributes(struct zip *za, zip_uint64_t idx, zip_flags_t flags, zip_uint8_t opsys, zip_uint32_t attributes)</span>
<span class='curline'><a href='../S/1293.html#L44'>za</a>                 44 ext/zip/lib/zip_file_set_external_attributes.c     if (_zip_get_dirent(za, idx, 0, NULL) == NULL)</span>
<span class='curline'><a href='../S/1293.html#L47'>za</a>                 47 ext/zip/lib/zip_file_set_external_attributes.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1293.html#L48'>za</a>                 48 ext/zip/lib/zip_file_set_external_attributes.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1293.html#L52'>za</a>                 52 ext/zip/lib/zip_file_set_external_attributes.c     e = za-&gt;entry+idx;</span>
<span class='curline'><a href='../S/1293.html#L62'>za</a>                 62 ext/zip/lib/zip_file_set_external_attributes.c                 _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1296.html#L41'>za</a>                 41 ext/zip/lib/zip_fopen.c zip_fopen(struct zip *za, const char *fname, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1296.html#L45'>za</a>                 45 ext/zip/lib/zip_fopen.c     if ((idx=zip_name_locate(za, fname, flags)) &lt; 0)</span>
<span class='curline'><a href='../S/1296.html#L48'>za</a>                 48 ext/zip/lib/zip_fopen.c     return zip_fopen_index_encrypted(za, (zip_uint64_t)idx, flags, za-&gt;default_password);</span>
<span class='curline'><a href='../S/1297.html#L41'>za</a>                 41 ext/zip/lib/zip_fopen_encrypted.c zip_fopen_encrypted(struct zip *za, const char *fname, zip_flags_t flags, const char *password)</span>
<span class='curline'><a href='../S/1297.html#L45'>za</a>                 45 ext/zip/lib/zip_fopen_encrypted.c     if ((idx=zip_name_locate(za, fname, flags)) &lt; 0)</span>
<span class='curline'><a href='../S/1297.html#L48'>za</a>                 48 ext/zip/lib/zip_fopen_encrypted.c     return zip_fopen_index_encrypted(za, (zip_uint64_t)idx, flags, password);</span>
<span class='curline'><a href='../S/1298.html#L45'>za</a>                 45 ext/zip/lib/zip_fopen_index.c zip_fopen_index(struct zip *za, zip_uint64_t index, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1298.html#L47'>za</a>                 47 ext/zip/lib/zip_fopen_index.c     return zip_fopen_index_encrypted(za, index, flags, za-&gt;default_password);</span>
<span class='curline'><a href='../S/1299.html#L42'>za</a>                 42 ext/zip/lib/zip_fopen_index_encrypted.c static struct zip_file *_zip_file_new(struct zip *za);</span>
<span class='curline'><a href='../S/1299.html#L47'>za</a>                 47 ext/zip/lib/zip_fopen_index_encrypted.c zip_fopen_index_encrypted(struct zip *za, zip_uint64_t index, zip_flags_t flags,</span>
<span class='curline'><a href='../S/1299.html#L53'>za</a>                 53 ext/zip/lib/zip_fopen_index_encrypted.c     if ((src=_zip_source_zip_new(za, za, index, flags, 0, 0, password)) == NULL)</span>
<span class='curline'><a href='../S/1299.html#L57'>za</a>                 57 ext/zip/lib/zip_fopen_index_encrypted.c 	_zip_error_set_from_source(&amp;za-&gt;error, src);</span>
<span class='curline'><a href='../S/1299.html#L62'>za</a>                 62 ext/zip/lib/zip_fopen_index_encrypted.c     if ((zf=_zip_file_new(za)) == NULL) {</span>
<span class='curline'><a href='../S/1299.html#L75'>za</a>                 75 ext/zip/lib/zip_fopen_index_encrypted.c _zip_file_new(struct zip *za)</span>
<span class='curline'><a href='../S/1299.html#L80'>za</a>                 80 ext/zip/lib/zip_fopen_index_encrypted.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1299.html#L84'>za</a>                 84 ext/zip/lib/zip_fopen_index_encrypted.c     if (za-&gt;nfile+1 &gt;= za-&gt;nfile_alloc) {</span>
<span class='curline'><a href='../S/1299.html#L86'>za</a>                 86 ext/zip/lib/zip_fopen_index_encrypted.c 	n = za-&gt;nfile_alloc + 10;</span>
<span class='curline'><a href='../S/1299.html#L87'>za</a>                 87 ext/zip/lib/zip_fopen_index_encrypted.c 	file = (struct zip_file **)realloc(za-&gt;file,</span>
<span class='curline'><a href='../S/1299.html#L90'>za</a>                 90 ext/zip/lib/zip_fopen_index_encrypted.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1299.html#L94'>za</a>                 94 ext/zip/lib/zip_fopen_index_encrypted.c 	za-&gt;nfile_alloc = n;</span>
<span class='curline'><a href='../S/1299.html#L95'>za</a>                 95 ext/zip/lib/zip_fopen_index_encrypted.c 	za-&gt;file = file;</span>
<span class='curline'><a href='../S/1299.html#L98'>za</a>                 98 ext/zip/lib/zip_fopen_index_encrypted.c     za-&gt;file[za-&gt;nfile++] = zf;</span>
<span class='curline'><a href='../S/1299.html#L100'>za</a>                100 ext/zip/lib/zip_fopen_index_encrypted.c     zf-&gt;za = za;</span>
<span class='curline'><a href='../S/1301.html#L43'>za</a>                 43 ext/zip/lib/zip_get_archive_comment.c zip_get_archive_comment(struct zip *za, int *lenp, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1301.html#L49'>za</a>                 49 ext/zip/lib/zip_get_archive_comment.c     if ((flags &amp; ZIP_FL_UNCHANGED) || (za-&gt;comment_changes == NULL))</span>
<span class='curline'><a href='../S/1301.html#L50'>za</a>                 50 ext/zip/lib/zip_get_archive_comment.c 	comment = za-&gt;comment_orig;</span>
<span class='curline'><a href='../S/1301.html#L52'>za</a>                 52 ext/zip/lib/zip_get_archive_comment.c 	comment = za-&gt;comment_changes;</span>
<span class='curline'><a href='../S/1301.html#L54'>za</a>                 54 ext/zip/lib/zip_get_archive_comment.c     if ((str=_zip_string_get(comment, &amp;len, flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1302.html#L41'>za</a>                 41 ext/zip/lib/zip_get_archive_flag.c zip_get_archive_flag(struct zip *za, zip_flags_t flag, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1302.html#L45'>za</a>                 45 ext/zip/lib/zip_get_archive_flag.c     fl = (flags &amp; ZIP_FL_UNCHANGED) ? za-&gt;flags : za-&gt;ch_flags;</span>
<span class='curline'><a href='../S/1305.html#L42'>za</a>                 42 ext/zip/lib/zip_get_file_comment.c zip_get_file_comment(struct zip *za, zip_uint64_t idx, int *lenp, int flags)</span>
<span class='curline'><a href='../S/1305.html#L47'>za</a>                 47 ext/zip/lib/zip_get_file_comment.c     if ((s=zip_file_get_comment(za, idx, &amp;len, (zip_flags_t)flags)) != NULL) {</span>
<span class='curline'><a href='../S/1306.html#L43'>za</a>                 43 ext/zip/lib/zip_get_name.c zip_get_name(struct zip *za, zip_uint64_t idx, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1306.html#L45'>za</a>                 45 ext/zip/lib/zip_get_name.c     return _zip_get_name(za, idx, flags, &amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1306.html#L51'>za</a>                 51 ext/zip/lib/zip_get_name.c _zip_get_name(struct zip *za, zip_uint64_t idx, zip_flags_t flags, struct zip_error *error)</span>
<span class='curline'><a href='../S/1306.html#L56'>za</a>                 56 ext/zip/lib/zip_get_name.c     if ((de=_zip_get_dirent(za, idx, flags, error)) == NULL)</span>
<span class='curline'><a href='../S/1307.html#L41'>za</a>                 41 ext/zip/lib/zip_get_num_entries.c zip_get_num_entries(struct zip *za, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1307.html#L45'>za</a>                 45 ext/zip/lib/zip_get_num_entries.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1307.html#L49'>za</a>                 49 ext/zip/lib/zip_get_num_entries.c 	n = za-&gt;nentry;</span>
<span class='curline'><a href='../S/1307.html#L50'>za</a>                 50 ext/zip/lib/zip_get_num_entries.c 	while (n&gt;0 &amp;&amp; za-&gt;entry[n-1].orig == NULL)</span>
<span class='curline'><a href='../S/1307.html#L54'>za</a>                 54 ext/zip/lib/zip_get_num_entries.c     return (zip_int64_t)za-&gt;nentry;</span>
<span class='curline'><a href='../S/1308.html#L42'>za</a>                 42 ext/zip/lib/zip_get_num_files.c zip_get_num_files(struct zip *za)</span>
<span class='curline'><a href='../S/1308.html#L44'>za</a>                 44 ext/zip/lib/zip_get_num_files.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1308.html#L48'>za</a>                 48 ext/zip/lib/zip_get_num_files.c     return (int)za-&gt;nentry;</span>
<span class='curline'><a href='../S/1310.html#L46'>za</a>                 46 ext/zip/lib/zip_name_locate.c zip_name_locate(struct zip *za, const char *fname, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1310.html#L48'>za</a>                 48 ext/zip/lib/zip_name_locate.c     return _zip_name_locate(za, fname, flags, &amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1310.html#L54'>za</a>                 54 ext/zip/lib/zip_name_locate.c _zip_name_locate(struct zip *za, const char *fname, zip_flags_t flags, struct zip_error *error)</span>
<span class='curline'><a href='../S/1310.html#L60'>za</a>                 60 ext/zip/lib/zip_name_locate.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1310.html#L70'>za</a>                 70 ext/zip/lib/zip_name_locate.c     for (i=0; i&lt;za-&gt;nentry; i++) {</span>
<span class='curline'><a href='../S/1310.html#L71'>za</a>                 71 ext/zip/lib/zip_name_locate.c 	fn = _zip_get_name(za, i, flags, error);</span>
<span class='curline'><a href='../S/1311.html#L49'>za</a>                 49 ext/zip/lib/zip_new.c     struct zip *za;</span>
<span class='curline'><a href='../S/1311.html#L51'>za</a>                 51 ext/zip/lib/zip_new.c     za = (struct zip *)malloc(sizeof(struct zip));</span>
<span class='curline'><a href='../S/1311.html#L52'>za</a>                 52 ext/zip/lib/zip_new.c     if (!za) {</span>
<span class='curline'><a href='../S/1311.html#L57'>za</a>                 57 ext/zip/lib/zip_new.c     za-&gt;zn = NULL;</span>
<span class='curline'><a href='../S/1311.html#L58'>za</a>                 58 ext/zip/lib/zip_new.c     za-&gt;zp = NULL;</span>
<span class='curline'><a href='../S/1311.html#L59'>za</a>                 59 ext/zip/lib/zip_new.c     za-&gt;open_flags = 0;</span>
<span class='curline'><a href='../S/1311.html#L60'>za</a>                 60 ext/zip/lib/zip_new.c     _zip_error_init(&amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1311.html#L61'>za</a>                 61 ext/zip/lib/zip_new.c     za-&gt;flags = za-&gt;ch_flags = 0;</span>
<span class='curline'><a href='../S/1311.html#L62'>za</a>                 62 ext/zip/lib/zip_new.c     za-&gt;default_password = NULL;</span>
<span class='curline'><a href='../S/1311.html#L63'>za</a>                 63 ext/zip/lib/zip_new.c     za-&gt;comment_orig = za-&gt;comment_changes = NULL;</span>
<span class='curline'><a href='../S/1311.html#L64'>za</a>                 64 ext/zip/lib/zip_new.c     za-&gt;comment_changed = 0;</span>
<span class='curline'><a href='../S/1311.html#L65'>za</a>                 65 ext/zip/lib/zip_new.c     za-&gt;nentry = za-&gt;nentry_alloc = 0;</span>
<span class='curline'><a href='../S/1311.html#L66'>za</a>                 66 ext/zip/lib/zip_new.c     za-&gt;entry = NULL;</span>
<span class='curline'><a href='../S/1311.html#L67'>za</a>                 67 ext/zip/lib/zip_new.c     za-&gt;nfile = za-&gt;nfile_alloc = 0;</span>
<span class='curline'><a href='../S/1311.html#L68'>za</a>                 68 ext/zip/lib/zip_new.c     za-&gt;file = NULL;</span>
<span class='curline'><a href='../S/1311.html#L69'>za</a>                 69 ext/zip/lib/zip_new.c     za-&gt;tempdir = NULL;</span>
<span class='curline'><a href='../S/1311.html#L71'>za</a>                 71 ext/zip/lib/zip_new.c     return za;</span>
<span class='curline'><a href='../S/1312.html#L105'>za</a>                105 ext/zip/lib/zip_open.c zip_archive_set_tempdir(struct zip *za, const char *tempdir)</span>
<span class='curline'><a href='../S/1312.html#L111'>za</a>                111 ext/zip/lib/zip_open.c             _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, errno);</span>
<span class='curline'><a href='../S/1312.html#L118'>za</a>                118 ext/zip/lib/zip_open.c     free(za-&gt;tempdir);</span>
<span class='curline'><a href='../S/1312.html#L119'>za</a>                119 ext/zip/lib/zip_open.c     za-&gt;tempdir = new_tempdir;</span>
<span class='curline'><a href='../S/1312.html#L128'>za</a>                128 ext/zip/lib/zip_open.c     struct zip *za;</span>
<span class='curline'><a href='../S/1312.html#L140'>za</a>                140 ext/zip/lib/zip_open.c 	if ((za=_zip_allocate_new(fn, flags, zep)) == NULL)</span>
<span class='curline'><a href='../S/1312.html#L143'>za</a>                143 ext/zip/lib/zip_open.c 	    za-&gt;zp = fp;</span>
<span class='curline'><a href='../S/1312.html#L144'>za</a>                144 ext/zip/lib/zip_open.c 	return za;</span>
<span class='curline'><a href='../S/1312.html#L153'>za</a>                153 ext/zip/lib/zip_open.c     if ((za=_zip_allocate_new(fn, flags, zep)) == NULL) {</span>
<span class='curline'><a href='../S/1312.html#L159'>za</a>                159 ext/zip/lib/zip_open.c     za-&gt;entry = cdir-&gt;entry;</span>
<span class='curline'><a href='../S/1312.html#L160'>za</a>                160 ext/zip/lib/zip_open.c     za-&gt;nentry = cdir-&gt;nentry;</span>
<span class='curline'><a href='../S/1312.html#L161'>za</a>                161 ext/zip/lib/zip_open.c     za-&gt;nentry_alloc = cdir-&gt;nentry_alloc;</span>
<span class='curline'><a href='../S/1312.html#L162'>za</a>                162 ext/zip/lib/zip_open.c     za-&gt;comment_orig = cdir-&gt;comment;</span>
<span class='curline'><a href='../S/1312.html#L164'>za</a>                164 ext/zip/lib/zip_open.c     za-&gt;zp = fp;</span>
<span class='curline'><a href='../S/1312.html#L166'>za</a>                166 ext/zip/lib/zip_open.c     _zip_check_torrentzip(za, cdir);</span>
<span class='curline'><a href='../S/1312.html#L168'>za</a>                168 ext/zip/lib/zip_open.c     za-&gt;ch_flags = za-&gt;flags;</span>
<span class='curline'><a href='../S/1312.html#L172'>za</a>                172 ext/zip/lib/zip_open.c     return za;</span>
<span class='curline'><a href='../S/1312.html#L370'>za</a>                370 ext/zip/lib/zip_open.c _zip_check_torrentzip(struct zip *za, const struct zip_cdir *cdir)</span>
<span class='curline'><a href='../S/1312.html#L376'>za</a>                376 ext/zip/lib/zip_open.c     if (za-&gt;zp == NULL || cdir == NULL)</span>
<span class='curline'><a href='../S/1312.html#L390'>za</a>                390 ext/zip/lib/zip_open.c     if (_zip_filerange_crc(za-&gt;zp, cdir-&gt;offset, cdir-&gt;size, &amp;crc_got, NULL) &lt; 0)</span>
<span class='curline'><a href='../S/1312.html#L394'>za</a>                394 ext/zip/lib/zip_open.c 	za-&gt;flags |= ZIP_AFL_TORRENT;</span>
<span class='curline'><a href='../S/1312.html#L436'>za</a>                436 ext/zip/lib/zip_open.c     struct zip *za;</span>
<span class='curline'><a href='../S/1312.html#L439'>za</a>                439 ext/zip/lib/zip_open.c     if ((za=_zip_new(&amp;error)) == NULL) {</span>
<span class='curline'><a href='../S/1312.html#L445'>za</a>                445 ext/zip/lib/zip_open.c 	za-&gt;zn = NULL;</span>
<span class='curline'><a href='../S/1312.html#L447'>za</a>                447 ext/zip/lib/zip_open.c 	za-&gt;zn = strdup(fn);</span>
<span class='curline'><a href='../S/1312.html#L448'>za</a>                448 ext/zip/lib/zip_open.c 	if (!za-&gt;zn) {</span>
<span class='curline'><a href='../S/1312.html#L449'>za</a>                449 ext/zip/lib/zip_open.c 	    zip_discard(za);</span>
<span class='curline'><a href='../S/1312.html#L454'>za</a>                454 ext/zip/lib/zip_open.c     za-&gt;open_flags = flags;</span>
<span class='curline'><a href='../S/1312.html#L455'>za</a>                455 ext/zip/lib/zip_open.c     return za;</span>
<span class='curline'><a href='../S/1313.html#L44'>za</a>                 44 ext/zip/lib/zip_rename.c zip_rename(struct zip *za, zip_uint64_t idx, const char *name)</span>
<span class='curline'><a href='../S/1313.html#L46'>za</a>                 46 ext/zip/lib/zip_rename.c     return zip_file_rename(za, idx, name, 0);</span>
<span class='curline'><a href='../S/1314.html#L42'>za</a>                 42 ext/zip/lib/zip_replace.c zip_replace(struct zip *za, zip_uint64_t idx, struct zip_source *source)</span>
<span class='curline'><a href='../S/1314.html#L44'>za</a>                 44 ext/zip/lib/zip_replace.c     return zip_file_replace(za, idx, source, 0);</span>
<span class='curline'><a href='../S/1315.html#L43'>za</a>                 43 ext/zip/lib/zip_set_archive_comment.c zip_set_archive_comment(struct zip *za, const char *comment, zip_uint16_t len)</span>
<span class='curline'><a href='../S/1315.html#L47'>za</a>                 47 ext/zip/lib/zip_set_archive_comment.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1315.html#L48'>za</a>                 48 ext/zip/lib/zip_set_archive_comment.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1315.html#L53'>za</a>                 53 ext/zip/lib/zip_set_archive_comment.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1315.html#L58'>za</a>                 58 ext/zip/lib/zip_set_archive_comment.c 	if ((cstr=_zip_string_new((const zip_uint8_t *)comment, len, ZIP_FL_ENC_GUESS, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1315.html#L63'>za</a>                 63 ext/zip/lib/zip_set_archive_comment.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1315.html#L70'>za</a>                 70 ext/zip/lib/zip_set_archive_comment.c     _zip_string_free(za-&gt;comment_changes);</span>
<span class='curline'><a href='../S/1315.html#L71'>za</a>                 71 ext/zip/lib/zip_set_archive_comment.c     za-&gt;comment_changes = NULL;</span>
<span class='curline'><a href='../S/1315.html#L73'>za</a>                 73 ext/zip/lib/zip_set_archive_comment.c     if (((za-&gt;comment_orig &amp;&amp; _zip_string_equal(za-&gt;comment_orig, cstr))</span>
<span class='curline'><a href='../S/1315.html#L74'>za</a>                 74 ext/zip/lib/zip_set_archive_comment.c 	 || (za-&gt;comment_orig == NULL &amp;&amp; cstr == NULL))) {</span>
<span class='curline'><a href='../S/1315.html#L76'>za</a>                 76 ext/zip/lib/zip_set_archive_comment.c 	za-&gt;comment_changed = 0;</span>
<span class='curline'><a href='../S/1315.html#L79'>za</a>                 79 ext/zip/lib/zip_set_archive_comment.c 	za-&gt;comment_changes = cstr;</span>
<span class='curline'><a href='../S/1315.html#L80'>za</a>                 80 ext/zip/lib/zip_set_archive_comment.c 	za-&gt;comment_changed = 1;</span>
<span class='curline'><a href='../S/1316.html#L41'>za</a>                 41 ext/zip/lib/zip_set_archive_flag.c zip_set_archive_flag(struct zip *za, zip_flags_t flag, int value)</span>
<span class='curline'><a href='../S/1316.html#L46'>za</a>                 46 ext/zip/lib/zip_set_archive_flag.c 	new_flags = za-&gt;ch_flags | flag;</span>
<span class='curline'><a href='../S/1316.html#L48'>za</a>                 48 ext/zip/lib/zip_set_archive_flag.c 	new_flags = za-&gt;ch_flags &amp; ~flag;</span>
<span class='curline'><a href='../S/1316.html#L50'>za</a>                 50 ext/zip/lib/zip_set_archive_flag.c     if (new_flags == za-&gt;ch_flags)</span>
<span class='curline'><a href='../S/1316.html#L53'>za</a>                 53 ext/zip/lib/zip_set_archive_flag.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1316.html#L54'>za</a>                 54 ext/zip/lib/zip_set_archive_flag.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1316.html#L59'>za</a>                 59 ext/zip/lib/zip_set_archive_flag.c 	&amp;&amp; (za-&gt;ch_flags &amp; ZIP_AFL_RDONLY) == 0) {</span>
<span class='curline'><a href='../S/1316.html#L60'>za</a>                 60 ext/zip/lib/zip_set_archive_flag.c 	if (_zip_changed(za, NULL)) {</span>
<span class='curline'><a href='../S/1316.html#L61'>za</a>                 61 ext/zip/lib/zip_set_archive_flag.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_CHANGED, 0);</span>
<span class='curline'><a href='../S/1316.html#L66'>za</a>                 66 ext/zip/lib/zip_set_archive_flag.c     za-&gt;ch_flags = new_flags;</span>
<span class='curline'><a href='../S/1317.html#L44'>za</a>                 44 ext/zip/lib/zip_set_default_password.c zip_set_default_password(struct zip *za, const char *passwd)</span>
<span class='curline'><a href='../S/1317.html#L46'>za</a>                 46 ext/zip/lib/zip_set_default_password.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1317.html#L49'>za</a>                 49 ext/zip/lib/zip_set_default_password.c     if (za-&gt;default_password)</span>
<span class='curline'><a href='../S/1317.html#L50'>za</a>                 50 ext/zip/lib/zip_set_default_password.c 	free(za-&gt;default_password);</span>
<span class='curline'><a href='../S/1317.html#L53'>za</a>                 53 ext/zip/lib/zip_set_default_password.c 	if ((za-&gt;default_password=strdup(passwd)) == NULL) {</span>
<span class='curline'><a href='../S/1317.html#L54'>za</a>                 54 ext/zip/lib/zip_set_default_password.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1317.html#L59'>za</a>                 59 ext/zip/lib/zip_set_default_password.c 	za-&gt;default_password = NULL;</span>
<span class='curline'><a href='../S/1318.html#L44'>za</a>                 44 ext/zip/lib/zip_set_file_comment.c zip_set_file_comment(struct zip *za, zip_uint64_t idx, const char *comment, int len)</span>
<span class='curline'><a href='../S/1318.html#L47'>za</a>                 47 ext/zip/lib/zip_set_file_comment.c         _zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1318.html#L50'>za</a>                 50 ext/zip/lib/zip_set_file_comment.c     return zip_file_set_comment(za, idx, comment, (zip_uint16_t)len, 0);</span>
<span class='curline'><a href='../S/1319.html#L41'>za</a>                 41 ext/zip/lib/zip_set_file_compression.c zip_set_file_compression(struct zip *za, zip_uint64_t idx,</span>
<span class='curline'><a href='../S/1319.html#L47'>za</a>                 47 ext/zip/lib/zip_set_file_compression.c     if (idx &gt;= za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1319.html#L48'>za</a>                 48 ext/zip/lib/zip_set_file_compression.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1319.html#L52'>za</a>                 52 ext/zip/lib/zip_set_file_compression.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1319.html#L53'>za</a>                 53 ext/zip/lib/zip_set_file_compression.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1319.html#L58'>za</a>                 58 ext/zip/lib/zip_set_file_compression.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_COMPNOTSUPP, 0);</span>
<span class='curline'><a href='../S/1319.html#L62'>za</a>                 62 ext/zip/lib/zip_set_file_compression.c     e = za-&gt;entry+idx;</span>
<span class='curline'><a href='../S/1319.html#L80'>za</a>                 80 ext/zip/lib/zip_set_file_compression.c                 _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1320.html#L44'>za</a>                 44 ext/zip/lib/zip_set_name.c _zip_set_name(struct zip *za, zip_uint64_t idx, const char *name, zip_flags_t flags)</span>
<span class='curline'><a href='../S/1320.html#L51'>za</a>                 51 ext/zip/lib/zip_set_name.c     if (idx &gt;= za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1320.html#L52'>za</a>                 52 ext/zip/lib/zip_set_name.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1320.html#L56'>za</a>                 56 ext/zip/lib/zip_set_name.c     if (ZIP_IS_RDONLY(za)) {</span>
<span class='curline'><a href='../S/1320.html#L57'>za</a>                 57 ext/zip/lib/zip_set_name.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_RDONLY, 0);</span>
<span class='curline'><a href='../S/1320.html#L63'>za</a>                 63 ext/zip/lib/zip_set_name.c 	if ((str=_zip_string_new((const zip_uint8_t *)name, (zip_uint16_t)strlen(name), flags, &amp;za-&gt;error)) == NULL)</span>
<span class='curline'><a href='../S/1320.html#L72'>za</a>                 72 ext/zip/lib/zip_set_name.c     if ((i=_zip_name_locate(za, name, 0, NULL)) &gt;= 0 &amp;&amp; (zip_uint64_t)i != idx) {</span>
<span class='curline'><a href='../S/1320.html#L74'>za</a>                 74 ext/zip/lib/zip_set_name.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_EXISTS, 0);</span>
<span class='curline'><a href='../S/1320.html#L84'>za</a>                 84 ext/zip/lib/zip_set_name.c     e = za-&gt;entry+idx;</span>
<span class='curline'><a href='../S/1320.html#L100'>za</a>                100 ext/zip/lib/zip_set_name.c                 _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1321.html#L52'>za</a>                 52 ext/zip/lib/zip_source_buffer.c zip_source_buffer(struct zip *za, const void *data, zip_uint64_t len, int freep)</span>
<span class='curline'><a href='../S/1321.html#L57'>za</a>                 57 ext/zip/lib/zip_source_buffer.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1321.html#L61'>za</a>                 61 ext/zip/lib/zip_source_buffer.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1321.html#L66'>za</a>                 66 ext/zip/lib/zip_source_buffer.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1321.html#L75'>za</a>                 75 ext/zip/lib/zip_source_buffer.c     if ((zs=zip_source_function(za, read_data, f)) == NULL) {</span>
<span class='curline'><a href='../S/1323.html#L55'>za</a>                 55 ext/zip/lib/zip_source_crc.c zip_source_crc(struct zip *za, struct zip_source *src, int validate)</span>
<span class='curline'><a href='../S/1323.html#L60'>za</a>                 60 ext/zip/lib/zip_source_crc.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1323.html#L65'>za</a>                 65 ext/zip/lib/zip_source_crc.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1323.html#L75'>za</a>                 75 ext/zip/lib/zip_source_crc.c     return zip_source_layered(za, src, crc_read, ctx);</span>
<span class='curline'><a href='../S/1324.html#L64'>za</a>                 64 ext/zip/lib/zip_source_deflate.c zip_source_deflate(struct zip *za, struct zip_source *src,</span>
<span class='curline'><a href='../S/1324.html#L71'>za</a>                 71 ext/zip/lib/zip_source_deflate.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1324.html#L76'>za</a>                 76 ext/zip/lib/zip_source_deflate.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1324.html#L83'>za</a>                 83 ext/zip/lib/zip_source_deflate.c 	if (zip_get_archive_flag(za, ZIP_AFL_TORRENT, 0))</span>
<span class='curline'><a href='../S/1324.html#L89'>za</a>                 89 ext/zip/lib/zip_source_deflate.c     if ((s2=zip_source_layered(za, src,</span>
<span class='curline'><a href='../S/1326.html#L44'>za</a>                 44 ext/zip/lib/zip_source_file.c zip_source_file(struct zip *za, const char *fname, zip_uint64_t start,</span>
<span class='curline'><a href='../S/1326.html#L47'>za</a>                 47 ext/zip/lib/zip_source_file.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1326.html#L51'>za</a>                 51 ext/zip/lib/zip_source_file.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1326.html#L55'>za</a>                 55 ext/zip/lib/zip_source_file.c     return _zip_source_file_or_p(za, fname, NULL, start, len, 1, NULL);</span>
<span class='curline'><a href='../S/1327.html#L62'>za</a>                 62 ext/zip/lib/zip_source_filep.c zip_source_filep(struct zip *za, FILE *file, zip_uint64_t start,</span>
<span class='curline'><a href='../S/1327.html#L65'>za</a>                 65 ext/zip/lib/zip_source_filep.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1327.html#L69'>za</a>                 69 ext/zip/lib/zip_source_filep.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1327.html#L73'>za</a>                 73 ext/zip/lib/zip_source_filep.c     return _zip_source_file_or_p(za, NULL, file, start, len, 1, NULL);</span>
<span class='curline'><a href='../S/1327.html#L79'>za</a>                 79 ext/zip/lib/zip_source_filep.c _zip_source_file_or_p(struct zip *za, const char *fname, FILE *file,</span>
<span class='curline'><a href='../S/1327.html#L87'>za</a>                 87 ext/zip/lib/zip_source_filep.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1327.html#L92'>za</a>                 92 ext/zip/lib/zip_source_filep.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1327.html#L99'>za</a>                 99 ext/zip/lib/zip_source_filep.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1327.html#L113'>za</a>                113 ext/zip/lib/zip_source_filep.c     if ((zs=zip_source_function(za, read_file, f)) == NULL) {</span>
<span class='curline'><a href='../S/1329.html#L43'>za</a>                 43 ext/zip/lib/zip_source_function.c zip_source_function(struct zip *za, zip_source_callback zcb, void *ud)</span>
<span class='curline'><a href='../S/1329.html#L47'>za</a>                 47 ext/zip/lib/zip_source_function.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1329.html#L50'>za</a>                 50 ext/zip/lib/zip_source_function.c     if ((zs=_zip_source_new(za)) == NULL)</span>
<span class='curline'><a href='../S/1329.html#L62'>za</a>                 62 ext/zip/lib/zip_source_function.c _zip_source_new(struct zip *za)</span>
<span class='curline'><a href='../S/1329.html#L67'>za</a>                 67 ext/zip/lib/zip_source_function.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1330.html#L43'>za</a>                 43 ext/zip/lib/zip_source_layered.c zip_source_layered(struct zip *za, struct zip_source *src,</span>
<span class='curline'><a href='../S/1330.html#L48'>za</a>                 48 ext/zip/lib/zip_source_layered.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1330.html#L51'>za</a>                 51 ext/zip/lib/zip_source_layered.c     if ((zs=_zip_source_new(za)) == NULL)</span>
<span class='curline'><a href='../S/1332.html#L64'>za</a>                 64 ext/zip/lib/zip_source_pkware.c zip_source_pkware(struct zip *za, struct zip_source *src,</span>
<span class='curline'><a href='../S/1332.html#L71'>za</a>                 71 ext/zip/lib/zip_source_pkware.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1332.html#L75'>za</a>                 75 ext/zip/lib/zip_source_pkware.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_ENCRNOTSUPP, 0);</span>
<span class='curline'><a href='../S/1332.html#L80'>za</a>                 80 ext/zip/lib/zip_source_pkware.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1332.html#L91'>za</a>                 91 ext/zip/lib/zip_source_pkware.c     if ((s2=zip_source_layered(za, src, pkware_decrypt, ctx)) == NULL) {</span>
<span class='curline'><a href='../S/1336.html#L54'>za</a>                 54 ext/zip/lib/zip_source_window.c zip_source_window(struct zip *za, struct zip_source *src, zip_uint64_t start, zip_uint64_t len)</span>
<span class='curline'><a href='../S/1336.html#L59'>za</a>                 59 ext/zip/lib/zip_source_window.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1336.html#L64'>za</a>                 64 ext/zip/lib/zip_source_window.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_MEMORY, 0);</span>
<span class='curline'><a href='../S/1336.html#L72'>za</a>                 72 ext/zip/lib/zip_source_window.c     return zip_source_layered(za, src, window_read, ctx);</span>
<span class='curline'><a href='../S/1337.html#L44'>za</a>                 44 ext/zip/lib/zip_source_zip.c zip_source_zip(struct zip *za, struct zip *srcza, zip_uint64_t srcidx,</span>
<span class='curline'><a href='../S/1337.html#L48'>za</a>                 48 ext/zip/lib/zip_source_zip.c         _zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1337.html#L60'>za</a>                 60 ext/zip/lib/zip_source_zip.c     return _zip_source_zip_new(za, srcza, srcidx, flags, start, (zip_uint64_t)len, NULL);</span>
<span class='curline'><a href='../S/1338.html#L43'>za</a>                 43 ext/zip/lib/zip_source_zip_new.c _zip_source_zip_new(struct zip *za, struct zip *srcza, zip_uint64_t srcidx, zip_flags_t flags,</span>
<span class='curline'><a href='../S/1338.html#L52'>za</a>                 52 ext/zip/lib/zip_source_zip_new.c     if (za == NULL)</span>
<span class='curline'><a href='../S/1338.html#L56'>za</a>                 56 ext/zip/lib/zip_source_zip_new.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1338.html#L62'>za</a>                 62 ext/zip/lib/zip_source_zip_new.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_CHANGED, 0);</span>
<span class='curline'><a href='../S/1338.html#L67'>za</a>                 67 ext/zip/lib/zip_source_zip_new.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INTERNAL, 0);</span>
<span class='curline'><a href='../S/1338.html#L75'>za</a>                 75 ext/zip/lib/zip_source_zip_new.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1338.html#L81'>za</a>                 81 ext/zip/lib/zip_source_zip_new.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1338.html#L88'>za</a>                 88 ext/zip/lib/zip_source_zip_new.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_NOPASSWD, 0);</span>
<span class='curline'><a href='../S/1338.html#L92'>za</a>                 92 ext/zip/lib/zip_source_zip_new.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_ENCRNOTSUPP, 0);</span>
<span class='curline'><a href='../S/1338.html#L101'>za</a>                101 ext/zip/lib/zip_source_zip_new.c 		_zip_error_set(&amp;za-&gt;error, ZIP_ER_COMPNOTSUPP, 0);</span>
<span class='curline'><a href='../S/1338.html#L107'>za</a>                107 ext/zip/lib/zip_source_zip_new.c     if ((offset=_zip_file_get_offset(srcza, srcidx, &amp;za-&gt;error)) == 0)</span>
<span class='curline'><a href='../S/1338.html#L111'>za</a>                111 ext/zip/lib/zip_source_zip_new.c 	if ((src=zip_source_buffer(za, NULL, 0, 0)) == NULL)</span>
<span class='curline'><a href='../S/1338.html#L125'>za</a>                125 ext/zip/lib/zip_source_zip_new.c 	    if ((src=_zip_source_file_or_p(za, NULL, srcza-&gt;zp, offset+start, (zip_int64_t)st2.size, 0, &amp;st2)) == NULL)</span>
<span class='curline'><a href='../S/1338.html#L130'>za</a>                130 ext/zip/lib/zip_source_zip_new.c 	    if ((src=_zip_source_file_or_p(za, NULL, srcza-&gt;zp, offset, (zip_int64_t)st.comp_size, 0, &amp;st)) == NULL)</span>
<span class='curline'><a href='../S/1338.html#L135'>za</a>                135 ext/zip/lib/zip_source_zip_new.c 	    if ((s2=enc_impl(za, src, st.encryption_method, 0, password)) == NULL) {</span>
<span class='curline'><a href='../S/1338.html#L143'>za</a>                143 ext/zip/lib/zip_source_zip_new.c 	    if ((s2=comp_impl(za, src, st.comp_method, 0)) == NULL) {</span>
<span class='curline'><a href='../S/1338.html#L153'>za</a>                153 ext/zip/lib/zip_source_zip_new.c 	    if ((s2=zip_source_crc(za, src, 1)) == NULL) {</span>
<span class='curline'><a href='../S/1338.html#L162'>za</a>                162 ext/zip/lib/zip_source_zip_new.c 	    if ((s2=zip_source_window(za, src, start, len ? len : st.size-start)) == NULL) {</span>
<span class='curline'><a href='../S/1339.html#L41'>za</a>                 41 ext/zip/lib/zip_stat.c zip_stat(struct zip *za, const char *fname, zip_flags_t flags, struct zip_stat *st)</span>
<span class='curline'><a href='../S/1339.html#L45'>za</a>                 45 ext/zip/lib/zip_stat.c     if ((idx=zip_name_locate(za, fname, flags)) &lt; 0)</span>
<span class='curline'><a href='../S/1339.html#L48'>za</a>                 48 ext/zip/lib/zip_stat.c     return zip_stat_index(za, (zip_uint64_t)idx, flags, st);</span>
<span class='curline'><a href='../S/1340.html#L41'>za</a>                 41 ext/zip/lib/zip_stat_index.c zip_stat_index(struct zip *za, zip_uint64_t index, zip_flags_t flags,</span>
<span class='curline'><a href='../S/1340.html#L47'>za</a>                 47 ext/zip/lib/zip_stat_index.c     if ((de=_zip_get_dirent(za, index, flags, NULL)) == NULL)</span>
<span class='curline'><a href='../S/1340.html#L50'>za</a>                 50 ext/zip/lib/zip_stat_index.c     if ((name=zip_get_name(za, index, flags)) == NULL)</span>
<span class='curline'><a href='../S/1340.html#L55'>za</a>                 55 ext/zip/lib/zip_stat_index.c 	&amp;&amp; ZIP_ENTRY_DATA_CHANGED(za-&gt;entry+index)) {</span>
<span class='curline'><a href='../S/1340.html#L56'>za</a>                 56 ext/zip/lib/zip_stat_index.c 	if (zip_source_stat(za-&gt;entry[index].source, st) &lt; 0) {</span>
<span class='curline'><a href='../S/1340.html#L57'>za</a>                 57 ext/zip/lib/zip_stat_index.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_CHANGED, 0);</span>
<span class='curline'><a href='../S/1342.html#L41'>za</a>                 41 ext/zip/lib/zip_strerror.c zip_strerror(struct zip *za)</span>
<span class='curline'><a href='../S/1342.html#L43'>za</a>                 43 ext/zip/lib/zip_strerror.c     return _zip_error_strerror(&amp;za-&gt;error);</span>
<span class='curline'><a href='../S/1344.html#L43'>za</a>                 43 ext/zip/lib/zip_unchange.c zip_unchange(struct zip *za, zip_uint64_t idx)</span>
<span class='curline'><a href='../S/1344.html#L45'>za</a>                 45 ext/zip/lib/zip_unchange.c     return _zip_unchange(za, idx, 0);</span>
<span class='curline'><a href='../S/1344.html#L51'>za</a>                 51 ext/zip/lib/zip_unchange.c _zip_unchange(struct zip *za, zip_uint64_t idx, int allow_duplicates)</span>
<span class='curline'><a href='../S/1344.html#L55'>za</a>                 55 ext/zip/lib/zip_unchange.c     if (idx &gt;= za-&gt;nentry) {</span>
<span class='curline'><a href='../S/1344.html#L56'>za</a>                 56 ext/zip/lib/zip_unchange.c 	_zip_error_set(&amp;za-&gt;error, ZIP_ER_INVAL, 0);</span>
<span class='curline'><a href='../S/1344.html#L60'>za</a>                 60 ext/zip/lib/zip_unchange.c     if (!allow_duplicates &amp;&amp; za-&gt;entry[idx].changes &amp;&amp; (za-&gt;entry[idx].changes-&gt;changed &amp; ZIP_DIRENT_FILENAME)) {</span>
<span class='curline'><a href='../S/1344.html#L61'>za</a>                 61 ext/zip/lib/zip_unchange.c 	i = _zip_name_locate(za, _zip_get_name(za, idx, ZIP_FL_UNCHANGED, NULL), 0, NULL);</span>
<span class='curline'><a href='../S/1344.html#L63'>za</a>                 63 ext/zip/lib/zip_unchange.c 	    _zip_error_set(&amp;za-&gt;error, ZIP_ER_EXISTS, 0);</span>
<span class='curline'><a href='../S/1344.html#L68'>za</a>                 68 ext/zip/lib/zip_unchange.c     _zip_dirent_free(za-&gt;entry[idx].changes);</span>
<span class='curline'><a href='../S/1344.html#L69'>za</a>                 69 ext/zip/lib/zip_unchange.c     za-&gt;entry[idx].changes = NULL;</span>
<span class='curline'><a href='../S/1344.html#L71'>za</a>                 71 ext/zip/lib/zip_unchange.c     _zip_unchange_data(za-&gt;entry+idx);</span>
<span class='curline'><a href='../S/1345.html#L43'>za</a>                 43 ext/zip/lib/zip_unchange_all.c zip_unchange_all(struct zip *za)</span>
<span class='curline'><a href='../S/1345.html#L49'>za</a>                 49 ext/zip/lib/zip_unchange_all.c     for (i=0; i&lt;za-&gt;nentry; i++)</span>
<span class='curline'><a href='../S/1345.html#L50'>za</a>                 50 ext/zip/lib/zip_unchange_all.c 	ret |= _zip_unchange(za, i, 1);</span>
<span class='curline'><a href='../S/1345.html#L52'>za</a>                 52 ext/zip/lib/zip_unchange_all.c     ret |= zip_unchange_archive(za);</span>
<span class='curline'><a href='../S/1346.html#L43'>za</a>                 43 ext/zip/lib/zip_unchange_archive.c zip_unchange_archive(struct zip *za)</span>
<span class='curline'><a href='../S/1346.html#L45'>za</a>                 45 ext/zip/lib/zip_unchange_archive.c     if (za-&gt;comment_changed) {</span>
<span class='curline'><a href='../S/1346.html#L46'>za</a>                 46 ext/zip/lib/zip_unchange_archive.c 	_zip_string_free(za-&gt;comment_changes);</span>
<span class='curline'><a href='../S/1346.html#L47'>za</a>                 47 ext/zip/lib/zip_unchange_archive.c 	za-&gt;comment_changes = NULL;</span>
<span class='curline'><a href='../S/1346.html#L48'>za</a>                 48 ext/zip/lib/zip_unchange_archive.c 	za-&gt;comment_changed = 0;</span>
<span class='curline'><a href='../S/1346.html#L51'>za</a>                 51 ext/zip/lib/zip_unchange_archive.c     za-&gt;ch_flags = za-&gt;flags;</span>
<span class='curline'><a href='../S/1350.html#L300'>za</a>                300 ext/zip/lib/zipint.h     struct zip *za;		/* zip archive containing this file */</span>
<span class='curline'><a href='../S/1350.html#L412'>za</a>                412 ext/zip/lib/zipint.h #define ZIP_IS_RDONLY(za)	((za)-&gt;ch_flags &amp; ZIP_AFL_RDONLY)</span>
<span class='curline'><a href='../S/1351.html#L79'>za</a>                 79 ext/zip/php_zip.c #define PHP_ZIP_STAT_INDEX(za, index, flags, sb) \</span>
<span class='curline'><a href='../S/1351.html#L80'>za</a>                 80 ext/zip/php_zip.c 	if (zip_stat_index(za, index, flags, &amp;sb) != 0) { \</span>
<span class='curline'><a href='../S/1351.html#L86'>za</a>                 86 ext/zip/php_zip.c #define PHP_ZIP_STAT_PATH(za, path, path_len, flags, sb) \</span>
<span class='curline'><a href='../S/1351.html#L91'>za</a>                 91 ext/zip/php_zip.c 	if (zip_stat(za, path, flags, &amp;sb) != 0) { \</span>
<span class='curline'><a href='../S/1351.html#L97'>za</a>                 97 ext/zip/php_zip.c #define PHP_ZIP_SET_FILE_COMMENT(za, index, comment, comment_len) \</span>
<span class='curline'><a href='../S/1351.html#L163'>za</a>                163 ext/zip/php_zip.c static int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len TSRMLS_DC)</span>
<span class='curline'><a href='../S/1351.html#L196'>za</a>                196 ext/zip/php_zip.c 	if (path_cleaned_len &gt;= MAXPATHLEN || zip_stat(za, file, 0, &amp;sb) != 0) {</span>
<span class='curline'><a href='../S/1351.html#L293'>za</a>                293 ext/zip/php_zip.c 	zf = zip_fopen(za, file, 0);</span>
<span class='curline'><a href='../S/1351.html#L323'>za</a>                323 ext/zip/php_zip.c static int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len,</span>
<span class='curline'><a href='../S/1351.html#L344'>za</a>                344 ext/zip/php_zip.c 	zs = zip_source_file(za, resolved_path, offset_start, offset_len);</span>
<span class='curline'><a href='../S/1351.html#L348'>za</a>                348 ext/zip/php_zip.c 	if (zip_file_add(za, entry_name, zs, ZIP_FL_OVERWRITE) &lt; 0) {</span>
<span class='curline'><a href='../S/1351.html#L352'>za</a>                352 ext/zip/php_zip.c 		zip_error_clear(za);</span>
<span class='curline'><a href='../S/1351.html#L428'>za</a>                428 ext/zip/php_zip.c 		intern = obj-&gt;za; \</span>
<span class='curline'><a href='../S/1351.html#L450'>za</a>                450 ext/zip/php_zip.c static int php_zip_status(struct zip *za TSRMLS_DC) /* {{{ */</span>
<span class='curline'><a href='../S/1351.html#L454'>za</a>                454 ext/zip/php_zip.c 	zip_error_get(za, &amp;zep, &amp;syp);</span>
<span class='curline'><a href='../S/1351.html#L459'>za</a>                459 ext/zip/php_zip.c static int php_zip_status_sys(struct zip *za TSRMLS_DC) /* {{{ */</span>
<span class='curline'><a href='../S/1351.html#L463'>za</a>                463 ext/zip/php_zip.c 	zip_error_get(za, &amp;zep, &amp;syp);</span>
<span class='curline'><a href='../S/1351.html#L468'>za</a>                468 ext/zip/php_zip.c static int php_zip_get_num_files(struct zip *za TSRMLS_DC) /* {{{ */</span>
<span class='curline'><a href='../S/1351.html#L470'>za</a>                470 ext/zip/php_zip.c 	return zip_get_num_files(za);</span>
<span class='curline'><a href='../S/1351.html#L488'>za</a>                488 ext/zip/php_zip.c static char * php_zipobj_get_zip_comment(struct zip *za, int *len TSRMLS_DC) /* {{{ */</span>
<span class='curline'><a href='../S/1351.html#L490'>za</a>                490 ext/zip/php_zip.c 	if (za) {</span>
<span class='curline'><a href='../S/1351.html#L491'>za</a>                491 ext/zip/php_zip.c 		return (char *)zip_get_archive_comment(za, len, 0);</span>
<span class='curline'><a href='../S/1351.html#L808'>za</a>                808 ext/zip/php_zip.c typedef int (*zip_read_int_t)(struct zip *za TSRMLS_DC);</span>
<span class='curline'><a href='../S/1351.html#L809'>za</a>                809 ext/zip/php_zip.c typedef char *(*zip_read_const_char_t)(struct zip *za, int *len TSRMLS_DC);</span>
<span class='curline'><a href='../S/1351.html#L841'>za</a>                841 ext/zip/php_zip.c 	if (obj &amp;&amp; obj-&gt;za != NULL) {</span>
<span class='curline'><a href='../S/1351.html#L843'>za</a>                843 ext/zip/php_zip.c 			retchar = hnd-&gt;read_const_char_func(obj-&gt;za, &amp;len TSRMLS_CC);</span>
<span class='curline'><a href='../S/1351.html#L846'>za</a>                846 ext/zip/php_zip.c 				retint = hnd-&gt;read_int_func(obj-&gt;za TSRMLS_CC);</span>
<span class='curline'><a href='../S/1351.html#L1087'>za</a>               1087 ext/zip/php_zip.c 	if (intern-&gt;za) {</span>
<span class='curline'><a href='../S/1351.html#L1088'>za</a>               1088 ext/zip/php_zip.c 		if (zip_close(intern-&gt;za) != 0) {</span>
<span class='curline'><a href='../S/1351.html#L1092'>za</a>               1092 ext/zip/php_zip.c 		intern-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1351.html#L1102'>za</a>               1102 ext/zip/php_zip.c 	intern-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1351.html#L1136'>za</a>               1136 ext/zip/php_zip.c 	intern-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1351.html#L1177'>za</a>               1177 ext/zip/php_zip.c 		if (zip_int-&gt;za) {</span>
<span class='curline'><a href='../S/1351.html#L1178'>za</a>               1178 ext/zip/php_zip.c 			if (zip_close(zip_int-&gt;za) != 0) {</span>
<span class='curline'><a href='../S/1351.html#L1181'>za</a>               1181 ext/zip/php_zip.c 			zip_int-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1351.html#L1267'>za</a>               1267 ext/zip/php_zip.c 	rsrc_int-&gt;za = zip_open(resolved_path, 0, &amp;err);</span>
<span class='curline'><a href='../S/1351.html#L1268'>za</a>               1268 ext/zip/php_zip.c 	if (rsrc_int-&gt;za == NULL) {</span>
<span class='curline'><a href='../S/1351.html#L1274'>za</a>               1274 ext/zip/php_zip.c 	rsrc_int-&gt;num_files = zip_get_num_files(rsrc_int-&gt;za);</span>
<span class='curline'><a href='../S/1351.html#L1311'>za</a>               1311 ext/zip/php_zip.c 	if (rsrc_int &amp;&amp; rsrc_int-&gt;za) {</span>
<span class='curline'><a href='../S/1351.html#L1318'>za</a>               1318 ext/zip/php_zip.c 		ret = zip_stat_index(rsrc_int-&gt;za, rsrc_int-&gt;index_current, 0, &amp;zr_rsrc-&gt;sb);</span>
<span class='curline'><a href='../S/1351.html#L1325'>za</a>               1325 ext/zip/php_zip.c 		zr_rsrc-&gt;zf = zip_fopen_index(rsrc_int-&gt;za, rsrc_int-&gt;index_current, 0);</span>
<span class='curline'><a href='../S/1351.html#L1553'>za</a>               1553 ext/zip/php_zip.c 	if (ze_obj-&gt;za) {</span>
<span class='curline'><a href='../S/1351.html#L1555'>za</a>               1555 ext/zip/php_zip.c 		if (zip_close(ze_obj-&gt;za) != 0) {</span>
<span class='curline'><a href='../S/1351.html#L1560'>za</a>               1560 ext/zip/php_zip.c 		ze_obj-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1351.html#L1574'>za</a>               1574 ext/zip/php_zip.c 	ze_obj-&gt;za = intern;</span>
<span class='curline'><a href='../S/1351.html#L1636'>za</a>               1636 ext/zip/php_zip.c 	ze_obj-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1352.html#L64'>za</a>                 64 ext/zip/php_zip.h 	struct zip *za;</span>
<span class='curline'><a href='../S/1352.html#L84'>za</a>                 84 ext/zip/php_zip.h 	struct zip *za;</span>
<span class='curline'><a href='../S/1353.html#L35'>za</a>                 35 ext/zip/zip_stream.c 	struct zip *za;</span>
<span class='curline'><a href='../S/1353.html#L51'>za</a>                 51 ext/zip/zip_stream.c 	if (self-&gt;za &amp;&amp; self-&gt;zf) {</span>
<span class='curline'><a href='../S/1353.html#L93'>za</a>                 93 ext/zip/zip_stream.c 		if (self-&gt;za) {</span>
<span class='curline'><a href='../S/1353.html#L94'>za</a>                 94 ext/zip/zip_stream.c 			zip_close(self-&gt;za);</span>
<span class='curline'><a href='../S/1353.html#L95'>za</a>                 95 ext/zip/zip_stream.c 			self-&gt;za = NULL;</span>
<span class='curline'><a href='../S/1353.html#L123'>za</a>                123 ext/zip/zip_stream.c 	struct zip *za;</span>
<span class='curline'><a href='../S/1353.html#L159'>za</a>                159 ext/zip/zip_stream.c 	za = zip_open(file_dirname, ZIP_CREATE, &amp;err);</span>
<span class='curline'><a href='../S/1353.html#L160'>za</a>                160 ext/zip/zip_stream.c 	if (za) {</span>
<span class='curline'><a href='../S/1353.html#L162'>za</a>                162 ext/zip/zip_stream.c 		if (zip_stat(za, fragment, ZIP_FL_NOCASE, &amp;sb) != 0) {</span>
<span class='curline'><a href='../S/1353.html#L166'>za</a>                166 ext/zip/zip_stream.c 		zip_close(za);</span>
<span class='curline'><a href='../S/1353.html#L231'>za</a>                231 ext/zip/zip_stream.c 			self-&gt;za = stream_za;</span>
<span class='curline'><a href='../S/1353.html#L265'>za</a>                265 ext/zip/zip_stream.c 	struct zip *za;</span>
<span class='curline'><a href='../S/1353.html#L304'>za</a>                304 ext/zip/zip_stream.c 	za = zip_open(file_dirname, ZIP_CREATE, &amp;err);</span>
<span class='curline'><a href='../S/1353.html#L305'>za</a>                305 ext/zip/zip_stream.c 	if (za) {</span>
<span class='curline'><a href='../S/1353.html#L306'>za</a>                306 ext/zip/zip_stream.c 		zf = zip_fopen(za, fragment, 0);</span>
<span class='curline'><a href='../S/1353.html#L310'>za</a>                310 ext/zip/zip_stream.c 			self-&gt;za = za;</span>
<span class='curline'><a href='../S/1353.html#L320'>za</a>                320 ext/zip/zip_stream.c 			zip_close(za);</span>
</pre>
</body>
</html>
